// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: raft.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_raft_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_raft_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_raft_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_raft_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_raft_2eproto;
namespace dingodb {
namespace pb {
namespace raft {
class PutIfAbsentRequest;
struct PutIfAbsentRequestDefaultTypeInternal;
extern PutIfAbsentRequestDefaultTypeInternal _PutIfAbsentRequest_default_instance_;
class PutIfAbsentResponse;
struct PutIfAbsentResponseDefaultTypeInternal;
extern PutIfAbsentResponseDefaultTypeInternal _PutIfAbsentResponse_default_instance_;
class PutRequest;
struct PutRequestDefaultTypeInternal;
extern PutRequestDefaultTypeInternal _PutRequest_default_instance_;
class PutResponse;
struct PutResponseDefaultTypeInternal;
extern PutResponseDefaultTypeInternal _PutResponse_default_instance_;
class RaftCmdRequest;
struct RaftCmdRequestDefaultTypeInternal;
extern RaftCmdRequestDefaultTypeInternal _RaftCmdRequest_default_instance_;
class RaftCmdResponse;
struct RaftCmdResponseDefaultTypeInternal;
extern RaftCmdResponseDefaultTypeInternal _RaftCmdResponse_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestHeader;
struct RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class ResponseHeader;
struct ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
}  // namespace raft
}  // namespace pb
}  // namespace dingodb
PROTOBUF_NAMESPACE_OPEN
template<> ::dingodb::pb::raft::PutIfAbsentRequest* Arena::CreateMaybeMessage<::dingodb::pb::raft::PutIfAbsentRequest>(Arena*);
template<> ::dingodb::pb::raft::PutIfAbsentResponse* Arena::CreateMaybeMessage<::dingodb::pb::raft::PutIfAbsentResponse>(Arena*);
template<> ::dingodb::pb::raft::PutRequest* Arena::CreateMaybeMessage<::dingodb::pb::raft::PutRequest>(Arena*);
template<> ::dingodb::pb::raft::PutResponse* Arena::CreateMaybeMessage<::dingodb::pb::raft::PutResponse>(Arena*);
template<> ::dingodb::pb::raft::RaftCmdRequest* Arena::CreateMaybeMessage<::dingodb::pb::raft::RaftCmdRequest>(Arena*);
template<> ::dingodb::pb::raft::RaftCmdResponse* Arena::CreateMaybeMessage<::dingodb::pb::raft::RaftCmdResponse>(Arena*);
template<> ::dingodb::pb::raft::Request* Arena::CreateMaybeMessage<::dingodb::pb::raft::Request>(Arena*);
template<> ::dingodb::pb::raft::RequestHeader* Arena::CreateMaybeMessage<::dingodb::pb::raft::RequestHeader>(Arena*);
template<> ::dingodb::pb::raft::Response* Arena::CreateMaybeMessage<::dingodb::pb::raft::Response>(Arena*);
template<> ::dingodb::pb::raft::ResponseHeader* Arena::CreateMaybeMessage<::dingodb::pb::raft::ResponseHeader>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace dingodb {
namespace pb {
namespace raft {

enum CmdType : int {
  NONE = 0,
  PUT = 1,
  PUTIFABSENT = 2,
  CmdType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CmdType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CmdType_IsValid(int value);
constexpr CmdType CmdType_MIN = NONE;
constexpr CmdType CmdType_MAX = PUTIFABSENT;
constexpr int CmdType_ARRAYSIZE = CmdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CmdType_descriptor();
template<typename T>
inline const std::string& CmdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CmdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CmdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CmdType_descriptor(), enum_t_value);
}
inline bool CmdType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CmdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CmdType>(
    CmdType_descriptor(), name, value);
}
// ===================================================================

class PutRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.raft.PutRequest) */ {
 public:
  inline PutRequest() : PutRequest(nullptr) {}
  ~PutRequest() override;
  explicit PROTOBUF_CONSTEXPR PutRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutRequest(const PutRequest& from);
  PutRequest(PutRequest&& from) noexcept
    : PutRequest() {
    *this = ::std::move(from);
  }

  inline PutRequest& operator=(const PutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutRequest& operator=(PutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutRequest* internal_default_instance() {
    return reinterpret_cast<const PutRequest*>(
               &_PutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PutRequest& a, PutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutRequest& from) {
    PutRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.raft.PutRequest";
  }
  protected:
  explicit PutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvsFieldNumber = 1,
  };
  // repeated .dingodb.pb.common.KeyValue kvs = 1 [json_name = "kvs"];
  int kvs_size() const;
  private:
  int _internal_kvs_size() const;
  public:
  void clear_kvs();
  ::dingodb::pb::common::KeyValue* mutable_kvs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::KeyValue >*
      mutable_kvs();
  private:
  const ::dingodb::pb::common::KeyValue& _internal_kvs(int index) const;
  ::dingodb::pb::common::KeyValue* _internal_add_kvs();
  public:
  const ::dingodb::pb::common::KeyValue& kvs(int index) const;
  ::dingodb::pb::common::KeyValue* add_kvs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::KeyValue >&
      kvs() const;

  // @@protoc_insertion_point(class_scope:dingodb.pb.raft.PutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::KeyValue > kvs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class PutResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:dingodb.pb.raft.PutResponse) */ {
 public:
  inline PutResponse() : PutResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PutResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutResponse(const PutResponse& from);
  PutResponse(PutResponse&& from) noexcept
    : PutResponse() {
    *this = ::std::move(from);
  }

  inline PutResponse& operator=(const PutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutResponse& operator=(PutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutResponse* internal_default_instance() {
    return reinterpret_cast<const PutResponse*>(
               &_PutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PutResponse& a, PutResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PutResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PutResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PutResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.raft.PutResponse";
  }
  protected:
  explicit PutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dingodb.pb.raft.PutResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class PutIfAbsentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.raft.PutIfAbsentRequest) */ {
 public:
  inline PutIfAbsentRequest() : PutIfAbsentRequest(nullptr) {}
  ~PutIfAbsentRequest() override;
  explicit PROTOBUF_CONSTEXPR PutIfAbsentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutIfAbsentRequest(const PutIfAbsentRequest& from);
  PutIfAbsentRequest(PutIfAbsentRequest&& from) noexcept
    : PutIfAbsentRequest() {
    *this = ::std::move(from);
  }

  inline PutIfAbsentRequest& operator=(const PutIfAbsentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutIfAbsentRequest& operator=(PutIfAbsentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutIfAbsentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutIfAbsentRequest* internal_default_instance() {
    return reinterpret_cast<const PutIfAbsentRequest*>(
               &_PutIfAbsentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PutIfAbsentRequest& a, PutIfAbsentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PutIfAbsentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutIfAbsentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutIfAbsentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutIfAbsentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutIfAbsentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutIfAbsentRequest& from) {
    PutIfAbsentRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutIfAbsentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.raft.PutIfAbsentRequest";
  }
  protected:
  explicit PutIfAbsentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvsFieldNumber = 1,
  };
  // repeated .dingodb.pb.common.KeyValue kvs = 1 [json_name = "kvs"];
  int kvs_size() const;
  private:
  int _internal_kvs_size() const;
  public:
  void clear_kvs();
  ::dingodb::pb::common::KeyValue* mutable_kvs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::KeyValue >*
      mutable_kvs();
  private:
  const ::dingodb::pb::common::KeyValue& _internal_kvs(int index) const;
  ::dingodb::pb::common::KeyValue* _internal_add_kvs();
  public:
  const ::dingodb::pb::common::KeyValue& kvs(int index) const;
  ::dingodb::pb::common::KeyValue* add_kvs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::KeyValue >&
      kvs() const;

  // @@protoc_insertion_point(class_scope:dingodb.pb.raft.PutIfAbsentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::KeyValue > kvs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class PutIfAbsentResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.raft.PutIfAbsentResponse) */ {
 public:
  inline PutIfAbsentResponse() : PutIfAbsentResponse(nullptr) {}
  ~PutIfAbsentResponse() override;
  explicit PROTOBUF_CONSTEXPR PutIfAbsentResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutIfAbsentResponse(const PutIfAbsentResponse& from);
  PutIfAbsentResponse(PutIfAbsentResponse&& from) noexcept
    : PutIfAbsentResponse() {
    *this = ::std::move(from);
  }

  inline PutIfAbsentResponse& operator=(const PutIfAbsentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutIfAbsentResponse& operator=(PutIfAbsentResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutIfAbsentResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutIfAbsentResponse* internal_default_instance() {
    return reinterpret_cast<const PutIfAbsentResponse*>(
               &_PutIfAbsentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PutIfAbsentResponse& a, PutIfAbsentResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PutIfAbsentResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutIfAbsentResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutIfAbsentResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutIfAbsentResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutIfAbsentResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutIfAbsentResponse& from) {
    PutIfAbsentResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutIfAbsentResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.raft.PutIfAbsentResponse";
  }
  protected:
  explicit PutIfAbsentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPutKeysFieldNumber = 1,
  };
  // repeated bytes put_keys = 1 [json_name = "putKeys"];
  int put_keys_size() const;
  private:
  int _internal_put_keys_size() const;
  public:
  void clear_put_keys();
  const std::string& put_keys(int index) const;
  std::string* mutable_put_keys(int index);
  void set_put_keys(int index, const std::string& value);
  void set_put_keys(int index, std::string&& value);
  void set_put_keys(int index, const char* value);
  void set_put_keys(int index, const void* value, size_t size);
  std::string* add_put_keys();
  void add_put_keys(const std::string& value);
  void add_put_keys(std::string&& value);
  void add_put_keys(const char* value);
  void add_put_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& put_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_put_keys();
  private:
  const std::string& _internal_put_keys(int index) const;
  std::string* _internal_add_put_keys();
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.raft.PutIfAbsentResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> put_keys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.raft.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit PROTOBUF_CONSTEXPR Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum CmdBodyCase {
    kPut = 2,
    kPutIfAbsent = 3,
    CMD_BODY_NOT_SET = 0,
  };

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Request& from) {
    Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.raft.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmdTypeFieldNumber = 1,
    kPutFieldNumber = 2,
    kPutIfAbsentFieldNumber = 3,
  };
  // .dingodb.pb.raft.CmdType cmd_type = 1 [json_name = "cmdType"];
  void clear_cmd_type();
  ::dingodb::pb::raft::CmdType cmd_type() const;
  void set_cmd_type(::dingodb::pb::raft::CmdType value);
  private:
  ::dingodb::pb::raft::CmdType _internal_cmd_type() const;
  void _internal_set_cmd_type(::dingodb::pb::raft::CmdType value);
  public:

  // .dingodb.pb.raft.PutRequest put = 2 [json_name = "put"];
  bool has_put() const;
  private:
  bool _internal_has_put() const;
  public:
  void clear_put();
  const ::dingodb::pb::raft::PutRequest& put() const;
  PROTOBUF_NODISCARD ::dingodb::pb::raft::PutRequest* release_put();
  ::dingodb::pb::raft::PutRequest* mutable_put();
  void set_allocated_put(::dingodb::pb::raft::PutRequest* put);
  private:
  const ::dingodb::pb::raft::PutRequest& _internal_put() const;
  ::dingodb::pb::raft::PutRequest* _internal_mutable_put();
  public:
  void unsafe_arena_set_allocated_put(
      ::dingodb::pb::raft::PutRequest* put);
  ::dingodb::pb::raft::PutRequest* unsafe_arena_release_put();

  // .dingodb.pb.raft.PutIfAbsentRequest put_if_absent = 3 [json_name = "putIfAbsent"];
  bool has_put_if_absent() const;
  private:
  bool _internal_has_put_if_absent() const;
  public:
  void clear_put_if_absent();
  const ::dingodb::pb::raft::PutIfAbsentRequest& put_if_absent() const;
  PROTOBUF_NODISCARD ::dingodb::pb::raft::PutIfAbsentRequest* release_put_if_absent();
  ::dingodb::pb::raft::PutIfAbsentRequest* mutable_put_if_absent();
  void set_allocated_put_if_absent(::dingodb::pb::raft::PutIfAbsentRequest* put_if_absent);
  private:
  const ::dingodb::pb::raft::PutIfAbsentRequest& _internal_put_if_absent() const;
  ::dingodb::pb::raft::PutIfAbsentRequest* _internal_mutable_put_if_absent();
  public:
  void unsafe_arena_set_allocated_put_if_absent(
      ::dingodb::pb::raft::PutIfAbsentRequest* put_if_absent);
  ::dingodb::pb::raft::PutIfAbsentRequest* unsafe_arena_release_put_if_absent();

  void clear_cmd_body();
  CmdBodyCase cmd_body_case() const;
  // @@protoc_insertion_point(class_scope:dingodb.pb.raft.Request)
 private:
  class _Internal;
  void set_has_put();
  void set_has_put_if_absent();

  inline bool has_cmd_body() const;
  inline void clear_has_cmd_body();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int cmd_type_;
    union CmdBodyUnion {
      constexpr CmdBodyUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::dingodb::pb::raft::PutRequest* put_;
      ::dingodb::pb::raft::PutIfAbsentRequest* put_if_absent_;
    } cmd_body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.raft.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit PROTOBUF_CONSTEXPR Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Response& from) {
    Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.raft.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmdTypeFieldNumber = 1,
  };
  // .dingodb.pb.raft.CmdType cmd_type = 1 [json_name = "cmdType"];
  void clear_cmd_type();
  ::dingodb::pb::raft::CmdType cmd_type() const;
  void set_cmd_type(::dingodb::pb::raft::CmdType value);
  private:
  ::dingodb::pb::raft::CmdType _internal_cmd_type() const;
  void _internal_set_cmd_type(::dingodb::pb::raft::CmdType value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.raft.Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int cmd_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class RequestHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.raft.RequestHeader) */ {
 public:
  inline RequestHeader() : RequestHeader(nullptr) {}
  ~RequestHeader() override;
  explicit PROTOBUF_CONSTEXPR RequestHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestHeader(const RequestHeader& from);
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestHeader& from) {
    RequestHeader::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.raft.RequestHeader";
  }
  protected:
  explicit RequestHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
  };
  // uint64 region_id = 1 [json_name = "regionId"];
  void clear_region_id();
  uint64_t region_id() const;
  void set_region_id(uint64_t value);
  private:
  uint64_t _internal_region_id() const;
  void _internal_set_region_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.raft.RequestHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t region_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class RaftCmdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.raft.RaftCmdRequest) */ {
 public:
  inline RaftCmdRequest() : RaftCmdRequest(nullptr) {}
  ~RaftCmdRequest() override;
  explicit PROTOBUF_CONSTEXPR RaftCmdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RaftCmdRequest(const RaftCmdRequest& from);
  RaftCmdRequest(RaftCmdRequest&& from) noexcept
    : RaftCmdRequest() {
    *this = ::std::move(from);
  }

  inline RaftCmdRequest& operator=(const RaftCmdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaftCmdRequest& operator=(RaftCmdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RaftCmdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RaftCmdRequest* internal_default_instance() {
    return reinterpret_cast<const RaftCmdRequest*>(
               &_RaftCmdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RaftCmdRequest& a, RaftCmdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RaftCmdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RaftCmdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RaftCmdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RaftCmdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RaftCmdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RaftCmdRequest& from) {
    RaftCmdRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RaftCmdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.raft.RaftCmdRequest";
  }
  protected:
  explicit RaftCmdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .dingodb.pb.raft.Request requests = 2 [json_name = "requests"];
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::dingodb::pb::raft::Request* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::raft::Request >*
      mutable_requests();
  private:
  const ::dingodb::pb::raft::Request& _internal_requests(int index) const;
  ::dingodb::pb::raft::Request* _internal_add_requests();
  public:
  const ::dingodb::pb::raft::Request& requests(int index) const;
  ::dingodb::pb::raft::Request* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::raft::Request >&
      requests() const;

  // .dingodb.pb.raft.RequestHeader header = 1 [json_name = "header"];
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::dingodb::pb::raft::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::dingodb::pb::raft::RequestHeader* release_header();
  ::dingodb::pb::raft::RequestHeader* mutable_header();
  void set_allocated_header(::dingodb::pb::raft::RequestHeader* header);
  private:
  const ::dingodb::pb::raft::RequestHeader& _internal_header() const;
  ::dingodb::pb::raft::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::dingodb::pb::raft::RequestHeader* header);
  ::dingodb::pb::raft::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:dingodb.pb.raft.RaftCmdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::raft::Request > requests_;
    ::dingodb::pb::raft::RequestHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class ResponseHeader final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:dingodb.pb.raft.ResponseHeader) */ {
 public:
  inline ResponseHeader() : ResponseHeader(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResponseHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseHeader(const ResponseHeader& from);
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResponseHeader& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResponseHeader& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.raft.ResponseHeader";
  }
  protected:
  explicit ResponseHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dingodb.pb.raft.ResponseHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_raft_2eproto;
};
// -------------------------------------------------------------------

class RaftCmdResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.raft.RaftCmdResponse) */ {
 public:
  inline RaftCmdResponse() : RaftCmdResponse(nullptr) {}
  ~RaftCmdResponse() override;
  explicit PROTOBUF_CONSTEXPR RaftCmdResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RaftCmdResponse(const RaftCmdResponse& from);
  RaftCmdResponse(RaftCmdResponse&& from) noexcept
    : RaftCmdResponse() {
    *this = ::std::move(from);
  }

  inline RaftCmdResponse& operator=(const RaftCmdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RaftCmdResponse& operator=(RaftCmdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RaftCmdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RaftCmdResponse* internal_default_instance() {
    return reinterpret_cast<const RaftCmdResponse*>(
               &_RaftCmdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RaftCmdResponse& a, RaftCmdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RaftCmdResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RaftCmdResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RaftCmdResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RaftCmdResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RaftCmdResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RaftCmdResponse& from) {
    RaftCmdResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RaftCmdResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.raft.RaftCmdResponse";
  }
  protected:
  explicit RaftCmdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponsesFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .dingodb.pb.raft.Response responses = 2 [json_name = "responses"];
  int responses_size() const;
  private:
  int _internal_responses_size() const;
  public:
  void clear_responses();
  ::dingodb::pb::raft::Response* mutable_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::raft::Response >*
      mutable_responses();
  private:
  const ::dingodb::pb::raft::Response& _internal_responses(int index) const;
  ::dingodb::pb::raft::Response* _internal_add_responses();
  public:
  const ::dingodb::pb::raft::Response& responses(int index) const;
  ::dingodb::pb::raft::Response* add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::raft::Response >&
      responses() const;

  // .dingodb.pb.raft.ResponseHeader header = 1 [json_name = "header"];
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::dingodb::pb::raft::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::dingodb::pb::raft::ResponseHeader* release_header();
  ::dingodb::pb::raft::ResponseHeader* mutable_header();
  void set_allocated_header(::dingodb::pb::raft::ResponseHeader* header);
  private:
  const ::dingodb::pb::raft::ResponseHeader& _internal_header() const;
  ::dingodb::pb::raft::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::dingodb::pb::raft::ResponseHeader* header);
  ::dingodb::pb::raft::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:dingodb.pb.raft.RaftCmdResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::raft::Response > responses_;
    ::dingodb::pb::raft::ResponseHeader* header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_raft_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PutRequest

// repeated .dingodb.pb.common.KeyValue kvs = 1 [json_name = "kvs"];
inline int PutRequest::_internal_kvs_size() const {
  return _impl_.kvs_.size();
}
inline int PutRequest::kvs_size() const {
  return _internal_kvs_size();
}
inline ::dingodb::pb::common::KeyValue* PutRequest::mutable_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:dingodb.pb.raft.PutRequest.kvs)
  return _impl_.kvs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::KeyValue >*
PutRequest::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_list:dingodb.pb.raft.PutRequest.kvs)
  return &_impl_.kvs_;
}
inline const ::dingodb::pb::common::KeyValue& PutRequest::_internal_kvs(int index) const {
  return _impl_.kvs_.Get(index);
}
inline const ::dingodb::pb::common::KeyValue& PutRequest::kvs(int index) const {
  // @@protoc_insertion_point(field_get:dingodb.pb.raft.PutRequest.kvs)
  return _internal_kvs(index);
}
inline ::dingodb::pb::common::KeyValue* PutRequest::_internal_add_kvs() {
  return _impl_.kvs_.Add();
}
inline ::dingodb::pb::common::KeyValue* PutRequest::add_kvs() {
  ::dingodb::pb::common::KeyValue* _add = _internal_add_kvs();
  // @@protoc_insertion_point(field_add:dingodb.pb.raft.PutRequest.kvs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::KeyValue >&
PutRequest::kvs() const {
  // @@protoc_insertion_point(field_list:dingodb.pb.raft.PutRequest.kvs)
  return _impl_.kvs_;
}

// -------------------------------------------------------------------

// PutResponse

// -------------------------------------------------------------------

// PutIfAbsentRequest

// repeated .dingodb.pb.common.KeyValue kvs = 1 [json_name = "kvs"];
inline int PutIfAbsentRequest::_internal_kvs_size() const {
  return _impl_.kvs_.size();
}
inline int PutIfAbsentRequest::kvs_size() const {
  return _internal_kvs_size();
}
inline ::dingodb::pb::common::KeyValue* PutIfAbsentRequest::mutable_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:dingodb.pb.raft.PutIfAbsentRequest.kvs)
  return _impl_.kvs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::KeyValue >*
PutIfAbsentRequest::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_list:dingodb.pb.raft.PutIfAbsentRequest.kvs)
  return &_impl_.kvs_;
}
inline const ::dingodb::pb::common::KeyValue& PutIfAbsentRequest::_internal_kvs(int index) const {
  return _impl_.kvs_.Get(index);
}
inline const ::dingodb::pb::common::KeyValue& PutIfAbsentRequest::kvs(int index) const {
  // @@protoc_insertion_point(field_get:dingodb.pb.raft.PutIfAbsentRequest.kvs)
  return _internal_kvs(index);
}
inline ::dingodb::pb::common::KeyValue* PutIfAbsentRequest::_internal_add_kvs() {
  return _impl_.kvs_.Add();
}
inline ::dingodb::pb::common::KeyValue* PutIfAbsentRequest::add_kvs() {
  ::dingodb::pb::common::KeyValue* _add = _internal_add_kvs();
  // @@protoc_insertion_point(field_add:dingodb.pb.raft.PutIfAbsentRequest.kvs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::KeyValue >&
PutIfAbsentRequest::kvs() const {
  // @@protoc_insertion_point(field_list:dingodb.pb.raft.PutIfAbsentRequest.kvs)
  return _impl_.kvs_;
}

// -------------------------------------------------------------------

// PutIfAbsentResponse

// repeated bytes put_keys = 1 [json_name = "putKeys"];
inline int PutIfAbsentResponse::_internal_put_keys_size() const {
  return _impl_.put_keys_.size();
}
inline int PutIfAbsentResponse::put_keys_size() const {
  return _internal_put_keys_size();
}
inline void PutIfAbsentResponse::clear_put_keys() {
  _impl_.put_keys_.Clear();
}
inline std::string* PutIfAbsentResponse::add_put_keys() {
  std::string* _s = _internal_add_put_keys();
  // @@protoc_insertion_point(field_add_mutable:dingodb.pb.raft.PutIfAbsentResponse.put_keys)
  return _s;
}
inline const std::string& PutIfAbsentResponse::_internal_put_keys(int index) const {
  return _impl_.put_keys_.Get(index);
}
inline const std::string& PutIfAbsentResponse::put_keys(int index) const {
  // @@protoc_insertion_point(field_get:dingodb.pb.raft.PutIfAbsentResponse.put_keys)
  return _internal_put_keys(index);
}
inline std::string* PutIfAbsentResponse::mutable_put_keys(int index) {
  // @@protoc_insertion_point(field_mutable:dingodb.pb.raft.PutIfAbsentResponse.put_keys)
  return _impl_.put_keys_.Mutable(index);
}
inline void PutIfAbsentResponse::set_put_keys(int index, const std::string& value) {
  _impl_.put_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.raft.PutIfAbsentResponse.put_keys)
}
inline void PutIfAbsentResponse::set_put_keys(int index, std::string&& value) {
  _impl_.put_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:dingodb.pb.raft.PutIfAbsentResponse.put_keys)
}
inline void PutIfAbsentResponse::set_put_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.put_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dingodb.pb.raft.PutIfAbsentResponse.put_keys)
}
inline void PutIfAbsentResponse::set_put_keys(int index, const void* value, size_t size) {
  _impl_.put_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dingodb.pb.raft.PutIfAbsentResponse.put_keys)
}
inline std::string* PutIfAbsentResponse::_internal_add_put_keys() {
  return _impl_.put_keys_.Add();
}
inline void PutIfAbsentResponse::add_put_keys(const std::string& value) {
  _impl_.put_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dingodb.pb.raft.PutIfAbsentResponse.put_keys)
}
inline void PutIfAbsentResponse::add_put_keys(std::string&& value) {
  _impl_.put_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:dingodb.pb.raft.PutIfAbsentResponse.put_keys)
}
inline void PutIfAbsentResponse::add_put_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.put_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dingodb.pb.raft.PutIfAbsentResponse.put_keys)
}
inline void PutIfAbsentResponse::add_put_keys(const void* value, size_t size) {
  _impl_.put_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dingodb.pb.raft.PutIfAbsentResponse.put_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PutIfAbsentResponse::put_keys() const {
  // @@protoc_insertion_point(field_list:dingodb.pb.raft.PutIfAbsentResponse.put_keys)
  return _impl_.put_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PutIfAbsentResponse::mutable_put_keys() {
  // @@protoc_insertion_point(field_mutable_list:dingodb.pb.raft.PutIfAbsentResponse.put_keys)
  return &_impl_.put_keys_;
}

// -------------------------------------------------------------------

// Request

// .dingodb.pb.raft.CmdType cmd_type = 1 [json_name = "cmdType"];
inline void Request::clear_cmd_type() {
  _impl_.cmd_type_ = 0;
}
inline ::dingodb::pb::raft::CmdType Request::_internal_cmd_type() const {
  return static_cast< ::dingodb::pb::raft::CmdType >(_impl_.cmd_type_);
}
inline ::dingodb::pb::raft::CmdType Request::cmd_type() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.raft.Request.cmd_type)
  return _internal_cmd_type();
}
inline void Request::_internal_set_cmd_type(::dingodb::pb::raft::CmdType value) {
  
  _impl_.cmd_type_ = value;
}
inline void Request::set_cmd_type(::dingodb::pb::raft::CmdType value) {
  _internal_set_cmd_type(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.raft.Request.cmd_type)
}

// .dingodb.pb.raft.PutRequest put = 2 [json_name = "put"];
inline bool Request::_internal_has_put() const {
  return cmd_body_case() == kPut;
}
inline bool Request::has_put() const {
  return _internal_has_put();
}
inline void Request::set_has_put() {
  _impl_._oneof_case_[0] = kPut;
}
inline void Request::clear_put() {
  if (_internal_has_put()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_body_.put_;
    }
    clear_has_cmd_body();
  }
}
inline ::dingodb::pb::raft::PutRequest* Request::release_put() {
  // @@protoc_insertion_point(field_release:dingodb.pb.raft.Request.put)
  if (_internal_has_put()) {
    clear_has_cmd_body();
    ::dingodb::pb::raft::PutRequest* temp = _impl_.cmd_body_.put_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_body_.put_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dingodb::pb::raft::PutRequest& Request::_internal_put() const {
  return _internal_has_put()
      ? *_impl_.cmd_body_.put_
      : reinterpret_cast< ::dingodb::pb::raft::PutRequest&>(::dingodb::pb::raft::_PutRequest_default_instance_);
}
inline const ::dingodb::pb::raft::PutRequest& Request::put() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.raft.Request.put)
  return _internal_put();
}
inline ::dingodb::pb::raft::PutRequest* Request::unsafe_arena_release_put() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dingodb.pb.raft.Request.put)
  if (_internal_has_put()) {
    clear_has_cmd_body();
    ::dingodb::pb::raft::PutRequest* temp = _impl_.cmd_body_.put_;
    _impl_.cmd_body_.put_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_put(::dingodb::pb::raft::PutRequest* put) {
  clear_cmd_body();
  if (put) {
    set_has_put();
    _impl_.cmd_body_.put_ = put;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.raft.Request.put)
}
inline ::dingodb::pb::raft::PutRequest* Request::_internal_mutable_put() {
  if (!_internal_has_put()) {
    clear_cmd_body();
    set_has_put();
    _impl_.cmd_body_.put_ = CreateMaybeMessage< ::dingodb::pb::raft::PutRequest >(GetArenaForAllocation());
  }
  return _impl_.cmd_body_.put_;
}
inline ::dingodb::pb::raft::PutRequest* Request::mutable_put() {
  ::dingodb::pb::raft::PutRequest* _msg = _internal_mutable_put();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.raft.Request.put)
  return _msg;
}

// .dingodb.pb.raft.PutIfAbsentRequest put_if_absent = 3 [json_name = "putIfAbsent"];
inline bool Request::_internal_has_put_if_absent() const {
  return cmd_body_case() == kPutIfAbsent;
}
inline bool Request::has_put_if_absent() const {
  return _internal_has_put_if_absent();
}
inline void Request::set_has_put_if_absent() {
  _impl_._oneof_case_[0] = kPutIfAbsent;
}
inline void Request::clear_put_if_absent() {
  if (_internal_has_put_if_absent()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_body_.put_if_absent_;
    }
    clear_has_cmd_body();
  }
}
inline ::dingodb::pb::raft::PutIfAbsentRequest* Request::release_put_if_absent() {
  // @@protoc_insertion_point(field_release:dingodb.pb.raft.Request.put_if_absent)
  if (_internal_has_put_if_absent()) {
    clear_has_cmd_body();
    ::dingodb::pb::raft::PutIfAbsentRequest* temp = _impl_.cmd_body_.put_if_absent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_body_.put_if_absent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dingodb::pb::raft::PutIfAbsentRequest& Request::_internal_put_if_absent() const {
  return _internal_has_put_if_absent()
      ? *_impl_.cmd_body_.put_if_absent_
      : reinterpret_cast< ::dingodb::pb::raft::PutIfAbsentRequest&>(::dingodb::pb::raft::_PutIfAbsentRequest_default_instance_);
}
inline const ::dingodb::pb::raft::PutIfAbsentRequest& Request::put_if_absent() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.raft.Request.put_if_absent)
  return _internal_put_if_absent();
}
inline ::dingodb::pb::raft::PutIfAbsentRequest* Request::unsafe_arena_release_put_if_absent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dingodb.pb.raft.Request.put_if_absent)
  if (_internal_has_put_if_absent()) {
    clear_has_cmd_body();
    ::dingodb::pb::raft::PutIfAbsentRequest* temp = _impl_.cmd_body_.put_if_absent_;
    _impl_.cmd_body_.put_if_absent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_put_if_absent(::dingodb::pb::raft::PutIfAbsentRequest* put_if_absent) {
  clear_cmd_body();
  if (put_if_absent) {
    set_has_put_if_absent();
    _impl_.cmd_body_.put_if_absent_ = put_if_absent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.raft.Request.put_if_absent)
}
inline ::dingodb::pb::raft::PutIfAbsentRequest* Request::_internal_mutable_put_if_absent() {
  if (!_internal_has_put_if_absent()) {
    clear_cmd_body();
    set_has_put_if_absent();
    _impl_.cmd_body_.put_if_absent_ = CreateMaybeMessage< ::dingodb::pb::raft::PutIfAbsentRequest >(GetArenaForAllocation());
  }
  return _impl_.cmd_body_.put_if_absent_;
}
inline ::dingodb::pb::raft::PutIfAbsentRequest* Request::mutable_put_if_absent() {
  ::dingodb::pb::raft::PutIfAbsentRequest* _msg = _internal_mutable_put_if_absent();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.raft.Request.put_if_absent)
  return _msg;
}

inline bool Request::has_cmd_body() const {
  return cmd_body_case() != CMD_BODY_NOT_SET;
}
inline void Request::clear_has_cmd_body() {
  _impl_._oneof_case_[0] = CMD_BODY_NOT_SET;
}
inline Request::CmdBodyCase Request::cmd_body_case() const {
  return Request::CmdBodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// .dingodb.pb.raft.CmdType cmd_type = 1 [json_name = "cmdType"];
inline void Response::clear_cmd_type() {
  _impl_.cmd_type_ = 0;
}
inline ::dingodb::pb::raft::CmdType Response::_internal_cmd_type() const {
  return static_cast< ::dingodb::pb::raft::CmdType >(_impl_.cmd_type_);
}
inline ::dingodb::pb::raft::CmdType Response::cmd_type() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.raft.Response.cmd_type)
  return _internal_cmd_type();
}
inline void Response::_internal_set_cmd_type(::dingodb::pb::raft::CmdType value) {
  
  _impl_.cmd_type_ = value;
}
inline void Response::set_cmd_type(::dingodb::pb::raft::CmdType value) {
  _internal_set_cmd_type(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.raft.Response.cmd_type)
}

// -------------------------------------------------------------------

// RequestHeader

// uint64 region_id = 1 [json_name = "regionId"];
inline void RequestHeader::clear_region_id() {
  _impl_.region_id_ = uint64_t{0u};
}
inline uint64_t RequestHeader::_internal_region_id() const {
  return _impl_.region_id_;
}
inline uint64_t RequestHeader::region_id() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.raft.RequestHeader.region_id)
  return _internal_region_id();
}
inline void RequestHeader::_internal_set_region_id(uint64_t value) {
  
  _impl_.region_id_ = value;
}
inline void RequestHeader::set_region_id(uint64_t value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.raft.RequestHeader.region_id)
}

// -------------------------------------------------------------------

// RaftCmdRequest

// .dingodb.pb.raft.RequestHeader header = 1 [json_name = "header"];
inline bool RaftCmdRequest::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RaftCmdRequest::has_header() const {
  return _internal_has_header();
}
inline void RaftCmdRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::dingodb::pb::raft::RequestHeader& RaftCmdRequest::_internal_header() const {
  const ::dingodb::pb::raft::RequestHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::raft::RequestHeader&>(
      ::dingodb::pb::raft::_RequestHeader_default_instance_);
}
inline const ::dingodb::pb::raft::RequestHeader& RaftCmdRequest::header() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.raft.RaftCmdRequest.header)
  return _internal_header();
}
inline void RaftCmdRequest::unsafe_arena_set_allocated_header(
    ::dingodb::pb::raft::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.raft.RaftCmdRequest.header)
}
inline ::dingodb::pb::raft::RequestHeader* RaftCmdRequest::release_header() {
  
  ::dingodb::pb::raft::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::raft::RequestHeader* RaftCmdRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:dingodb.pb.raft.RaftCmdRequest.header)
  
  ::dingodb::pb::raft::RequestHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::dingodb::pb::raft::RequestHeader* RaftCmdRequest::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::raft::RequestHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::dingodb::pb::raft::RequestHeader* RaftCmdRequest::mutable_header() {
  ::dingodb::pb::raft::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.raft.RaftCmdRequest.header)
  return _msg;
}
inline void RaftCmdRequest::set_allocated_header(::dingodb::pb::raft::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.raft.RaftCmdRequest.header)
}

// repeated .dingodb.pb.raft.Request requests = 2 [json_name = "requests"];
inline int RaftCmdRequest::_internal_requests_size() const {
  return _impl_.requests_.size();
}
inline int RaftCmdRequest::requests_size() const {
  return _internal_requests_size();
}
inline void RaftCmdRequest::clear_requests() {
  _impl_.requests_.Clear();
}
inline ::dingodb::pb::raft::Request* RaftCmdRequest::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:dingodb.pb.raft.RaftCmdRequest.requests)
  return _impl_.requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::raft::Request >*
RaftCmdRequest::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:dingodb.pb.raft.RaftCmdRequest.requests)
  return &_impl_.requests_;
}
inline const ::dingodb::pb::raft::Request& RaftCmdRequest::_internal_requests(int index) const {
  return _impl_.requests_.Get(index);
}
inline const ::dingodb::pb::raft::Request& RaftCmdRequest::requests(int index) const {
  // @@protoc_insertion_point(field_get:dingodb.pb.raft.RaftCmdRequest.requests)
  return _internal_requests(index);
}
inline ::dingodb::pb::raft::Request* RaftCmdRequest::_internal_add_requests() {
  return _impl_.requests_.Add();
}
inline ::dingodb::pb::raft::Request* RaftCmdRequest::add_requests() {
  ::dingodb::pb::raft::Request* _add = _internal_add_requests();
  // @@protoc_insertion_point(field_add:dingodb.pb.raft.RaftCmdRequest.requests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::raft::Request >&
RaftCmdRequest::requests() const {
  // @@protoc_insertion_point(field_list:dingodb.pb.raft.RaftCmdRequest.requests)
  return _impl_.requests_;
}

// -------------------------------------------------------------------

// ResponseHeader

// -------------------------------------------------------------------

// RaftCmdResponse

// .dingodb.pb.raft.ResponseHeader header = 1 [json_name = "header"];
inline bool RaftCmdResponse::_internal_has_header() const {
  return this != internal_default_instance() && _impl_.header_ != nullptr;
}
inline bool RaftCmdResponse::has_header() const {
  return _internal_has_header();
}
inline void RaftCmdResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && _impl_.header_ != nullptr) {
    delete _impl_.header_;
  }
  _impl_.header_ = nullptr;
}
inline const ::dingodb::pb::raft::ResponseHeader& RaftCmdResponse::_internal_header() const {
  const ::dingodb::pb::raft::ResponseHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::raft::ResponseHeader&>(
      ::dingodb::pb::raft::_ResponseHeader_default_instance_);
}
inline const ::dingodb::pb::raft::ResponseHeader& RaftCmdResponse::header() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.raft.RaftCmdResponse.header)
  return _internal_header();
}
inline void RaftCmdResponse::unsafe_arena_set_allocated_header(
    ::dingodb::pb::raft::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.raft.RaftCmdResponse.header)
}
inline ::dingodb::pb::raft::ResponseHeader* RaftCmdResponse::release_header() {
  
  ::dingodb::pb::raft::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::raft::ResponseHeader* RaftCmdResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:dingodb.pb.raft.RaftCmdResponse.header)
  
  ::dingodb::pb::raft::ResponseHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::dingodb::pb::raft::ResponseHeader* RaftCmdResponse::_internal_mutable_header() {
  
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::raft::ResponseHeader>(GetArenaForAllocation());
    _impl_.header_ = p;
  }
  return _impl_.header_;
}
inline ::dingodb::pb::raft::ResponseHeader* RaftCmdResponse::mutable_header() {
  ::dingodb::pb::raft::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.raft.RaftCmdResponse.header)
  return _msg;
}
inline void RaftCmdResponse::set_allocated_header(::dingodb::pb::raft::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.header_ = header;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.raft.RaftCmdResponse.header)
}

// repeated .dingodb.pb.raft.Response responses = 2 [json_name = "responses"];
inline int RaftCmdResponse::_internal_responses_size() const {
  return _impl_.responses_.size();
}
inline int RaftCmdResponse::responses_size() const {
  return _internal_responses_size();
}
inline void RaftCmdResponse::clear_responses() {
  _impl_.responses_.Clear();
}
inline ::dingodb::pb::raft::Response* RaftCmdResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:dingodb.pb.raft.RaftCmdResponse.responses)
  return _impl_.responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::raft::Response >*
RaftCmdResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:dingodb.pb.raft.RaftCmdResponse.responses)
  return &_impl_.responses_;
}
inline const ::dingodb::pb::raft::Response& RaftCmdResponse::_internal_responses(int index) const {
  return _impl_.responses_.Get(index);
}
inline const ::dingodb::pb::raft::Response& RaftCmdResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:dingodb.pb.raft.RaftCmdResponse.responses)
  return _internal_responses(index);
}
inline ::dingodb::pb::raft::Response* RaftCmdResponse::_internal_add_responses() {
  return _impl_.responses_.Add();
}
inline ::dingodb::pb::raft::Response* RaftCmdResponse::add_responses() {
  ::dingodb::pb::raft::Response* _add = _internal_add_responses();
  // @@protoc_insertion_point(field_add:dingodb.pb.raft.RaftCmdResponse.responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::raft::Response >&
RaftCmdResponse::responses() const {
  // @@protoc_insertion_point(field_list:dingodb.pb.raft.RaftCmdResponse.responses)
  return _impl_.responses_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace raft
}  // namespace pb
}  // namespace dingodb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::dingodb::pb::raft::CmdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dingodb::pb::raft::CmdType>() {
  return ::dingodb::pb::raft::CmdType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_raft_2eproto
