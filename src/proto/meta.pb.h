// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meta.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_meta_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_meta_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "error.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_meta_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_meta_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_meta_2eproto;
namespace dingodb {
namespace pb {
namespace meta {
class ColumnDefinition;
struct ColumnDefinitionDefaultTypeInternal;
extern ColumnDefinitionDefaultTypeInternal _ColumnDefinition_default_instance_;
class CreateSchemaRequest;
struct CreateSchemaRequestDefaultTypeInternal;
extern CreateSchemaRequestDefaultTypeInternal _CreateSchemaRequest_default_instance_;
class CreateSchemaResponse;
struct CreateSchemaResponseDefaultTypeInternal;
extern CreateSchemaResponseDefaultTypeInternal _CreateSchemaResponse_default_instance_;
class CreateTableRequest;
struct CreateTableRequestDefaultTypeInternal;
extern CreateTableRequestDefaultTypeInternal _CreateTableRequest_default_instance_;
class CreateTableResponse;
struct CreateTableResponseDefaultTypeInternal;
extern CreateTableResponseDefaultTypeInternal _CreateTableResponse_default_instance_;
class DingoCommonId;
struct DingoCommonIdDefaultTypeInternal;
extern DingoCommonIdDefaultTypeInternal _DingoCommonId_default_instance_;
class DropTableRequest;
struct DropTableRequestDefaultTypeInternal;
extern DropTableRequestDefaultTypeInternal _DropTableRequest_default_instance_;
class DropTableResponse;
struct DropTableResponseDefaultTypeInternal;
extern DropTableResponseDefaultTypeInternal _DropTableResponse_default_instance_;
class GetSchemasRequest;
struct GetSchemasRequestDefaultTypeInternal;
extern GetSchemasRequestDefaultTypeInternal _GetSchemasRequest_default_instance_;
class GetSchemasResponse;
struct GetSchemasResponseDefaultTypeInternal;
extern GetSchemasResponseDefaultTypeInternal _GetSchemasResponse_default_instance_;
class GetTableRequest;
struct GetTableRequestDefaultTypeInternal;
extern GetTableRequestDefaultTypeInternal _GetTableRequest_default_instance_;
class GetTableResponse;
struct GetTableResponseDefaultTypeInternal;
extern GetTableResponseDefaultTypeInternal _GetTableResponse_default_instance_;
class GetTablesRequest;
struct GetTablesRequestDefaultTypeInternal;
extern GetTablesRequestDefaultTypeInternal _GetTablesRequest_default_instance_;
class GetTablesResponse;
struct GetTablesResponseDefaultTypeInternal;
extern GetTablesResponseDefaultTypeInternal _GetTablesResponse_default_instance_;
class HashPartition;
struct HashPartitionDefaultTypeInternal;
extern HashPartitionDefaultTypeInternal _HashPartition_default_instance_;
class Index;
struct IndexDefaultTypeInternal;
extern IndexDefaultTypeInternal _Index_default_instance_;
class Part;
struct PartDefaultTypeInternal;
extern PartDefaultTypeInternal _Part_default_instance_;
class PartitionRule;
struct PartitionRuleDefaultTypeInternal;
extern PartitionRuleDefaultTypeInternal _PartitionRule_default_instance_;
class RangePartition;
struct RangePartitionDefaultTypeInternal;
extern RangePartitionDefaultTypeInternal _RangePartition_default_instance_;
class Schema;
struct SchemaDefaultTypeInternal;
extern SchemaDefaultTypeInternal _Schema_default_instance_;
class Table;
struct TableDefaultTypeInternal;
extern TableDefaultTypeInternal _Table_default_instance_;
class TableDefinition;
struct TableDefinitionDefaultTypeInternal;
extern TableDefinitionDefaultTypeInternal _TableDefinition_default_instance_;
class TableDefinitionWithId;
struct TableDefinitionWithIdDefaultTypeInternal;
extern TableDefinitionWithIdDefaultTypeInternal _TableDefinitionWithId_default_instance_;
class TableDefinition_IndexesEntry_DoNotUse;
struct TableDefinition_IndexesEntry_DoNotUseDefaultTypeInternal;
extern TableDefinition_IndexesEntry_DoNotUseDefaultTypeInternal _TableDefinition_IndexesEntry_DoNotUse_default_instance_;
class TableDefinition_PropertiesEntry_DoNotUse;
struct TableDefinition_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern TableDefinition_PropertiesEntry_DoNotUseDefaultTypeInternal _TableDefinition_PropertiesEntry_DoNotUse_default_instance_;
}  // namespace meta
}  // namespace pb
}  // namespace dingodb
PROTOBUF_NAMESPACE_OPEN
template<> ::dingodb::pb::meta::ColumnDefinition* Arena::CreateMaybeMessage<::dingodb::pb::meta::ColumnDefinition>(Arena*);
template<> ::dingodb::pb::meta::CreateSchemaRequest* Arena::CreateMaybeMessage<::dingodb::pb::meta::CreateSchemaRequest>(Arena*);
template<> ::dingodb::pb::meta::CreateSchemaResponse* Arena::CreateMaybeMessage<::dingodb::pb::meta::CreateSchemaResponse>(Arena*);
template<> ::dingodb::pb::meta::CreateTableRequest* Arena::CreateMaybeMessage<::dingodb::pb::meta::CreateTableRequest>(Arena*);
template<> ::dingodb::pb::meta::CreateTableResponse* Arena::CreateMaybeMessage<::dingodb::pb::meta::CreateTableResponse>(Arena*);
template<> ::dingodb::pb::meta::DingoCommonId* Arena::CreateMaybeMessage<::dingodb::pb::meta::DingoCommonId>(Arena*);
template<> ::dingodb::pb::meta::DropTableRequest* Arena::CreateMaybeMessage<::dingodb::pb::meta::DropTableRequest>(Arena*);
template<> ::dingodb::pb::meta::DropTableResponse* Arena::CreateMaybeMessage<::dingodb::pb::meta::DropTableResponse>(Arena*);
template<> ::dingodb::pb::meta::GetSchemasRequest* Arena::CreateMaybeMessage<::dingodb::pb::meta::GetSchemasRequest>(Arena*);
template<> ::dingodb::pb::meta::GetSchemasResponse* Arena::CreateMaybeMessage<::dingodb::pb::meta::GetSchemasResponse>(Arena*);
template<> ::dingodb::pb::meta::GetTableRequest* Arena::CreateMaybeMessage<::dingodb::pb::meta::GetTableRequest>(Arena*);
template<> ::dingodb::pb::meta::GetTableResponse* Arena::CreateMaybeMessage<::dingodb::pb::meta::GetTableResponse>(Arena*);
template<> ::dingodb::pb::meta::GetTablesRequest* Arena::CreateMaybeMessage<::dingodb::pb::meta::GetTablesRequest>(Arena*);
template<> ::dingodb::pb::meta::GetTablesResponse* Arena::CreateMaybeMessage<::dingodb::pb::meta::GetTablesResponse>(Arena*);
template<> ::dingodb::pb::meta::HashPartition* Arena::CreateMaybeMessage<::dingodb::pb::meta::HashPartition>(Arena*);
template<> ::dingodb::pb::meta::Index* Arena::CreateMaybeMessage<::dingodb::pb::meta::Index>(Arena*);
template<> ::dingodb::pb::meta::Part* Arena::CreateMaybeMessage<::dingodb::pb::meta::Part>(Arena*);
template<> ::dingodb::pb::meta::PartitionRule* Arena::CreateMaybeMessage<::dingodb::pb::meta::PartitionRule>(Arena*);
template<> ::dingodb::pb::meta::RangePartition* Arena::CreateMaybeMessage<::dingodb::pb::meta::RangePartition>(Arena*);
template<> ::dingodb::pb::meta::Schema* Arena::CreateMaybeMessage<::dingodb::pb::meta::Schema>(Arena*);
template<> ::dingodb::pb::meta::Table* Arena::CreateMaybeMessage<::dingodb::pb::meta::Table>(Arena*);
template<> ::dingodb::pb::meta::TableDefinition* Arena::CreateMaybeMessage<::dingodb::pb::meta::TableDefinition>(Arena*);
template<> ::dingodb::pb::meta::TableDefinitionWithId* Arena::CreateMaybeMessage<::dingodb::pb::meta::TableDefinitionWithId>(Arena*);
template<> ::dingodb::pb::meta::TableDefinition_IndexesEntry_DoNotUse* Arena::CreateMaybeMessage<::dingodb::pb::meta::TableDefinition_IndexesEntry_DoNotUse>(Arena*);
template<> ::dingodb::pb::meta::TableDefinition_PropertiesEntry_DoNotUse* Arena::CreateMaybeMessage<::dingodb::pb::meta::TableDefinition_PropertiesEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace dingodb {
namespace pb {
namespace meta {

enum EntityType : int {
  ENTITY_TYPE_SCHEMA = 0,
  ENTITY_TYPE_TABLE = 1,
  ENTITY_TYPE_PART = 2,
  EntityType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EntityType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EntityType_IsValid(int value);
constexpr EntityType EntityType_MIN = ENTITY_TYPE_SCHEMA;
constexpr EntityType EntityType_MAX = ENTITY_TYPE_PART;
constexpr int EntityType_ARRAYSIZE = EntityType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EntityType_descriptor();
template<typename T>
inline const std::string& EntityType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EntityType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EntityType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EntityType_descriptor(), enum_t_value);
}
inline bool EntityType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EntityType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EntityType>(
    EntityType_descriptor(), name, value);
}
enum ReservedSchemaIds : int {
  ROOT_SCHEMA = 0,
  META_SCHEMA = 1,
  DINGO_SCHEMA = 2,
  ReservedSchemaIds_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ReservedSchemaIds_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ReservedSchemaIds_IsValid(int value);
constexpr ReservedSchemaIds ReservedSchemaIds_MIN = ROOT_SCHEMA;
constexpr ReservedSchemaIds ReservedSchemaIds_MAX = DINGO_SCHEMA;
constexpr int ReservedSchemaIds_ARRAYSIZE = ReservedSchemaIds_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReservedSchemaIds_descriptor();
template<typename T>
inline const std::string& ReservedSchemaIds_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReservedSchemaIds>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReservedSchemaIds_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReservedSchemaIds_descriptor(), enum_t_value);
}
inline bool ReservedSchemaIds_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReservedSchemaIds* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReservedSchemaIds>(
    ReservedSchemaIds_descriptor(), name, value);
}
enum SqlType : int {
  SQL_TYPE_BOOLEAN = 0,
  SQL_TYPE_INTEGER = 1,
  SQL_TYPE_BIGINT = 2,
  SQL_TYPE_DOUBLE = 3,
  SQL_TYPE_FLOAT = 4,
  SQL_TYPE_DATE = 5,
  SQL_TYPE_TIME = 6,
  SQL_TYPE_TIMESTAMP = 7,
  SQL_TYPE_VARCHAR = 8,
  SQL_TYPE_ARRAY = 9,
  SQL_TYPE_MULTISET = 10,
  SQL_TYPE_ANY = 11,
  SqlType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SqlType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SqlType_IsValid(int value);
constexpr SqlType SqlType_MIN = SQL_TYPE_BOOLEAN;
constexpr SqlType SqlType_MAX = SQL_TYPE_ANY;
constexpr int SqlType_ARRAYSIZE = SqlType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SqlType_descriptor();
template<typename T>
inline const std::string& SqlType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SqlType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SqlType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SqlType_descriptor(), enum_t_value);
}
inline bool SqlType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SqlType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SqlType>(
    SqlType_descriptor(), name, value);
}
enum ElementType : int {
  ELEM_TYPE_DOUBLE = 0,
  ELEM_TYPE_FLOAT = 1,
  ELEM_TYPE_INT32 = 2,
  ELEM_TYPE_INT64 = 3,
  ELEM_TYPE_UINT32 = 4,
  ELEM_TYPE_UINT64 = 5,
  ELEM_TYPE_BOOLEAN = 6,
  ELEM_TYPE_STRING = 7,
  ELEM_TYPE_BYTES = 8,
  ELEM_TYPE_FIX32 = 9,
  ELEM_TYPE_FIX64 = 10,
  ELEM_TYPE_SFIX32 = 11,
  ELEM_TYPE_SFIX64 = 12,
  ElementType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ElementType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ElementType_IsValid(int value);
constexpr ElementType ElementType_MIN = ELEM_TYPE_DOUBLE;
constexpr ElementType ElementType_MAX = ELEM_TYPE_SFIX64;
constexpr int ElementType_ARRAYSIZE = ElementType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ElementType_descriptor();
template<typename T>
inline const std::string& ElementType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ElementType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ElementType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ElementType_descriptor(), enum_t_value);
}
inline bool ElementType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ElementType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ElementType>(
    ElementType_descriptor(), name, value);
}
enum PartitionStrategy : int {
  PT_STRATEGY_RANGE = 0,
  PT_STRATEGY_HASH = 1,
  PartitionStrategy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PartitionStrategy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PartitionStrategy_IsValid(int value);
constexpr PartitionStrategy PartitionStrategy_MIN = PT_STRATEGY_RANGE;
constexpr PartitionStrategy PartitionStrategy_MAX = PT_STRATEGY_HASH;
constexpr int PartitionStrategy_ARRAYSIZE = PartitionStrategy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PartitionStrategy_descriptor();
template<typename T>
inline const std::string& PartitionStrategy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PartitionStrategy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PartitionStrategy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PartitionStrategy_descriptor(), enum_t_value);
}
inline bool PartitionStrategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PartitionStrategy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PartitionStrategy>(
    PartitionStrategy_descriptor(), name, value);
}
// ===================================================================

class DingoCommonId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.DingoCommonId) */ {
 public:
  inline DingoCommonId() : DingoCommonId(nullptr) {}
  ~DingoCommonId() override;
  explicit PROTOBUF_CONSTEXPR DingoCommonId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DingoCommonId(const DingoCommonId& from);
  DingoCommonId(DingoCommonId&& from) noexcept
    : DingoCommonId() {
    *this = ::std::move(from);
  }

  inline DingoCommonId& operator=(const DingoCommonId& from) {
    CopyFrom(from);
    return *this;
  }
  inline DingoCommonId& operator=(DingoCommonId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DingoCommonId& default_instance() {
    return *internal_default_instance();
  }
  static inline const DingoCommonId* internal_default_instance() {
    return reinterpret_cast<const DingoCommonId*>(
               &_DingoCommonId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DingoCommonId& a, DingoCommonId& b) {
    a.Swap(&b);
  }
  inline void Swap(DingoCommonId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DingoCommonId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DingoCommonId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DingoCommonId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DingoCommonId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DingoCommonId& from) {
    DingoCommonId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DingoCommonId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.DingoCommonId";
  }
  protected:
  explicit DingoCommonId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentEntityIdFieldNumber = 2,
    kEntityIdFieldNumber = 3,
    kEntityTypeFieldNumber = 1,
  };
  // uint64 parent_entity_id = 2 [json_name = "parentEntityId"];
  void clear_parent_entity_id();
  uint64_t parent_entity_id() const;
  void set_parent_entity_id(uint64_t value);
  private:
  uint64_t _internal_parent_entity_id() const;
  void _internal_set_parent_entity_id(uint64_t value);
  public:

  // uint64 entity_id = 3 [json_name = "entityId"];
  void clear_entity_id();
  uint64_t entity_id() const;
  void set_entity_id(uint64_t value);
  private:
  uint64_t _internal_entity_id() const;
  void _internal_set_entity_id(uint64_t value);
  public:

  // .dingodb.pb.meta.EntityType entity_type = 1 [json_name = "entityType"];
  void clear_entity_type();
  ::dingodb::pb::meta::EntityType entity_type() const;
  void set_entity_type(::dingodb::pb::meta::EntityType value);
  private:
  ::dingodb::pb::meta::EntityType _internal_entity_type() const;
  void _internal_set_entity_type(::dingodb::pb::meta::EntityType value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.DingoCommonId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t parent_entity_id_;
    uint64_t entity_id_;
    int entity_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class ColumnDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.ColumnDefinition) */ {
 public:
  inline ColumnDefinition() : ColumnDefinition(nullptr) {}
  ~ColumnDefinition() override;
  explicit PROTOBUF_CONSTEXPR ColumnDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnDefinition(const ColumnDefinition& from);
  ColumnDefinition(ColumnDefinition&& from) noexcept
    : ColumnDefinition() {
    *this = ::std::move(from);
  }

  inline ColumnDefinition& operator=(const ColumnDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnDefinition& operator=(ColumnDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnDefinition* internal_default_instance() {
    return reinterpret_cast<const ColumnDefinition*>(
               &_ColumnDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ColumnDefinition& a, ColumnDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnDefinition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnDefinition& from) {
    ColumnDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.ColumnDefinition";
  }
  protected:
  explicit ColumnDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDefaultValFieldNumber = 9,
    kSqlTypeFieldNumber = 2,
    kElementTypeFieldNumber = 3,
    kPrecisionFieldNumber = 4,
    kScaleFieldNumber = 5,
    kIndexOfKeyFieldNumber = 7,
    kNullableFieldNumber = 6,
    kHasDefaultValFieldNumber = 8,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string default_val = 9 [json_name = "defaultVal"];
  void clear_default_val();
  const std::string& default_val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_val();
  PROTOBUF_NODISCARD std::string* release_default_val();
  void set_allocated_default_val(std::string* default_val);
  private:
  const std::string& _internal_default_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_val(const std::string& value);
  std::string* _internal_mutable_default_val();
  public:

  // .dingodb.pb.meta.SqlType sql_type = 2 [json_name = "sqlType"];
  void clear_sql_type();
  ::dingodb::pb::meta::SqlType sql_type() const;
  void set_sql_type(::dingodb::pb::meta::SqlType value);
  private:
  ::dingodb::pb::meta::SqlType _internal_sql_type() const;
  void _internal_set_sql_type(::dingodb::pb::meta::SqlType value);
  public:

  // .dingodb.pb.meta.ElementType element_type = 3 [json_name = "elementType"];
  void clear_element_type();
  ::dingodb::pb::meta::ElementType element_type() const;
  void set_element_type(::dingodb::pb::meta::ElementType value);
  private:
  ::dingodb::pb::meta::ElementType _internal_element_type() const;
  void _internal_set_element_type(::dingodb::pb::meta::ElementType value);
  public:

  // int32 precision = 4 [json_name = "precision"];
  void clear_precision();
  int32_t precision() const;
  void set_precision(int32_t value);
  private:
  int32_t _internal_precision() const;
  void _internal_set_precision(int32_t value);
  public:

  // int32 scale = 5 [json_name = "scale"];
  void clear_scale();
  int32_t scale() const;
  void set_scale(int32_t value);
  private:
  int32_t _internal_scale() const;
  void _internal_set_scale(int32_t value);
  public:

  // int32 indexOfKey = 7 [json_name = "indexOfKey"];
  void clear_indexofkey();
  int32_t indexofkey() const;
  void set_indexofkey(int32_t value);
  private:
  int32_t _internal_indexofkey() const;
  void _internal_set_indexofkey(int32_t value);
  public:

  // bool nullable = 6 [json_name = "nullable"];
  void clear_nullable();
  bool nullable() const;
  void set_nullable(bool value);
  private:
  bool _internal_nullable() const;
  void _internal_set_nullable(bool value);
  public:

  // bool has_default_val = 8 [json_name = "hasDefaultVal"];
  void clear_has_default_val();
  bool has_default_val() const;
  void set_has_default_val(bool value);
  private:
  bool _internal_has_default_val() const;
  void _internal_set_has_default_val(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.ColumnDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_val_;
    int sql_type_;
    int element_type_;
    int32_t precision_;
    int32_t scale_;
    int32_t indexofkey_;
    bool nullable_;
    bool has_default_val_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class Index final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.Index) */ {
 public:
  inline Index() : Index(nullptr) {}
  ~Index() override;
  explicit PROTOBUF_CONSTEXPR Index(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Index(const Index& from);
  Index(Index&& from) noexcept
    : Index() {
    *this = ::std::move(from);
  }

  inline Index& operator=(const Index& from) {
    CopyFrom(from);
    return *this;
  }
  inline Index& operator=(Index&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Index& default_instance() {
    return *internal_default_instance();
  }
  static inline const Index* internal_default_instance() {
    return reinterpret_cast<const Index*>(
               &_Index_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Index& a, Index& b) {
    a.Swap(&b);
  }
  inline void Swap(Index* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Index* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Index* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Index>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Index& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Index& from) {
    Index::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Index* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.Index";
  }
  protected:
  explicit Index(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexColumnFieldNumber = 1,
    kIsUniqueFieldNumber = 2,
  };
  // repeated string index_column = 1 [json_name = "indexColumn"];
  int index_column_size() const;
  private:
  int _internal_index_column_size() const;
  public:
  void clear_index_column();
  const std::string& index_column(int index) const;
  std::string* mutable_index_column(int index);
  void set_index_column(int index, const std::string& value);
  void set_index_column(int index, std::string&& value);
  void set_index_column(int index, const char* value);
  void set_index_column(int index, const char* value, size_t size);
  std::string* add_index_column();
  void add_index_column(const std::string& value);
  void add_index_column(std::string&& value);
  void add_index_column(const char* value);
  void add_index_column(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& index_column() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_index_column();
  private:
  const std::string& _internal_index_column(int index) const;
  std::string* _internal_add_index_column();
  public:

  // bool is_unique = 2 [json_name = "isUnique"];
  void clear_is_unique();
  bool is_unique() const;
  void set_is_unique(bool value);
  private:
  bool _internal_is_unique() const;
  void _internal_set_is_unique(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.Index)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> index_column_;
    bool is_unique_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class RangePartition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.RangePartition) */ {
 public:
  inline RangePartition() : RangePartition(nullptr) {}
  ~RangePartition() override;
  explicit PROTOBUF_CONSTEXPR RangePartition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RangePartition(const RangePartition& from);
  RangePartition(RangePartition&& from) noexcept
    : RangePartition() {
    *this = ::std::move(from);
  }

  inline RangePartition& operator=(const RangePartition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangePartition& operator=(RangePartition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangePartition& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangePartition* internal_default_instance() {
    return reinterpret_cast<const RangePartition*>(
               &_RangePartition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RangePartition& a, RangePartition& b) {
    a.Swap(&b);
  }
  inline void Swap(RangePartition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangePartition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangePartition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RangePartition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RangePartition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RangePartition& from) {
    RangePartition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangePartition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.RangePartition";
  }
  protected:
  explicit RangePartition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRangesFieldNumber = 1,
  };
  // repeated .dingodb.pb.common.Range ranges = 1 [json_name = "ranges"];
  int ranges_size() const;
  private:
  int _internal_ranges_size() const;
  public:
  void clear_ranges();
  ::dingodb::pb::common::Range* mutable_ranges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Range >*
      mutable_ranges();
  private:
  const ::dingodb::pb::common::Range& _internal_ranges(int index) const;
  ::dingodb::pb::common::Range* _internal_add_ranges();
  public:
  const ::dingodb::pb::common::Range& ranges(int index) const;
  ::dingodb::pb::common::Range* add_ranges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Range >&
      ranges() const;

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.RangePartition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Range > ranges_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class HashPartition final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.HashPartition) */ {
 public:
  inline HashPartition() : HashPartition(nullptr) {}
  explicit PROTOBUF_CONSTEXPR HashPartition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HashPartition(const HashPartition& from);
  HashPartition(HashPartition&& from) noexcept
    : HashPartition() {
    *this = ::std::move(from);
  }

  inline HashPartition& operator=(const HashPartition& from) {
    CopyFrom(from);
    return *this;
  }
  inline HashPartition& operator=(HashPartition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HashPartition& default_instance() {
    return *internal_default_instance();
  }
  static inline const HashPartition* internal_default_instance() {
    return reinterpret_cast<const HashPartition*>(
               &_HashPartition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(HashPartition& a, HashPartition& b) {
    a.Swap(&b);
  }
  inline void Swap(HashPartition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HashPartition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HashPartition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HashPartition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HashPartition& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HashPartition& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.HashPartition";
  }
  protected:
  explicit HashPartition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.HashPartition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class PartitionRule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.PartitionRule) */ {
 public:
  inline PartitionRule() : PartitionRule(nullptr) {}
  ~PartitionRule() override;
  explicit PROTOBUF_CONSTEXPR PartitionRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartitionRule(const PartitionRule& from);
  PartitionRule(PartitionRule&& from) noexcept
    : PartitionRule() {
    *this = ::std::move(from);
  }

  inline PartitionRule& operator=(const PartitionRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionRule& operator=(PartitionRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionRule* internal_default_instance() {
    return reinterpret_cast<const PartitionRule*>(
               &_PartitionRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PartitionRule& a, PartitionRule& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartitionRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartitionRule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartitionRule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PartitionRule& from) {
    PartitionRule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.PartitionRule";
  }
  protected:
  explicit PartitionRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 1,
    kRangePartitionFieldNumber = 3,
    kHashPartitionFieldNumber = 4,
    kStrategyFieldNumber = 2,
  };
  // repeated string columns = 1 [json_name = "columns"];
  int columns_size() const;
  private:
  int _internal_columns_size() const;
  public:
  void clear_columns();
  const std::string& columns(int index) const;
  std::string* mutable_columns(int index);
  void set_columns(int index, const std::string& value);
  void set_columns(int index, std::string&& value);
  void set_columns(int index, const char* value);
  void set_columns(int index, const char* value, size_t size);
  std::string* add_columns();
  void add_columns(const std::string& value);
  void add_columns(std::string&& value);
  void add_columns(const char* value);
  void add_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns();
  private:
  const std::string& _internal_columns(int index) const;
  std::string* _internal_add_columns();
  public:

  // .dingodb.pb.meta.RangePartition range_partition = 3 [json_name = "rangePartition"];
  bool has_range_partition() const;
  private:
  bool _internal_has_range_partition() const;
  public:
  void clear_range_partition();
  const ::dingodb::pb::meta::RangePartition& range_partition() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::RangePartition* release_range_partition();
  ::dingodb::pb::meta::RangePartition* mutable_range_partition();
  void set_allocated_range_partition(::dingodb::pb::meta::RangePartition* range_partition);
  private:
  const ::dingodb::pb::meta::RangePartition& _internal_range_partition() const;
  ::dingodb::pb::meta::RangePartition* _internal_mutable_range_partition();
  public:
  void unsafe_arena_set_allocated_range_partition(
      ::dingodb::pb::meta::RangePartition* range_partition);
  ::dingodb::pb::meta::RangePartition* unsafe_arena_release_range_partition();

  // .dingodb.pb.meta.HashPartition hash_partition = 4 [json_name = "hashPartition"];
  bool has_hash_partition() const;
  private:
  bool _internal_has_hash_partition() const;
  public:
  void clear_hash_partition();
  const ::dingodb::pb::meta::HashPartition& hash_partition() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::HashPartition* release_hash_partition();
  ::dingodb::pb::meta::HashPartition* mutable_hash_partition();
  void set_allocated_hash_partition(::dingodb::pb::meta::HashPartition* hash_partition);
  private:
  const ::dingodb::pb::meta::HashPartition& _internal_hash_partition() const;
  ::dingodb::pb::meta::HashPartition* _internal_mutable_hash_partition();
  public:
  void unsafe_arena_set_allocated_hash_partition(
      ::dingodb::pb::meta::HashPartition* hash_partition);
  ::dingodb::pb::meta::HashPartition* unsafe_arena_release_hash_partition();

  // .dingodb.pb.meta.PartitionStrategy strategy = 2 [json_name = "strategy"];
  void clear_strategy();
  ::dingodb::pb::meta::PartitionStrategy strategy() const;
  void set_strategy(::dingodb::pb::meta::PartitionStrategy value);
  private:
  ::dingodb::pb::meta::PartitionStrategy _internal_strategy() const;
  void _internal_set_strategy(::dingodb::pb::meta::PartitionStrategy value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.PartitionRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_;
    ::dingodb::pb::meta::RangePartition* range_partition_;
    ::dingodb::pb::meta::HashPartition* hash_partition_;
    int strategy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class Schema final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.Schema) */ {
 public:
  inline Schema() : Schema(nullptr) {}
  ~Schema() override;
  explicit PROTOBUF_CONSTEXPR Schema(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Schema(const Schema& from);
  Schema(Schema&& from) noexcept
    : Schema() {
    *this = ::std::move(from);
  }

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }
  inline Schema& operator=(Schema&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Schema& default_instance() {
    return *internal_default_instance();
  }
  static inline const Schema* internal_default_instance() {
    return reinterpret_cast<const Schema*>(
               &_Schema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Schema& a, Schema& b) {
    a.Swap(&b);
  }
  inline void Swap(Schema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Schema* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Schema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Schema>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Schema& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Schema& from) {
    Schema::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Schema* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.Schema";
  }
  protected:
  explicit Schema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaIdsFieldNumber = 3,
    kTableIdsFieldNumber = 4,
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .dingodb.pb.meta.DingoCommonId schema_ids = 3 [json_name = "schemaIds"];
  int schema_ids_size() const;
  private:
  int _internal_schema_ids_size() const;
  public:
  void clear_schema_ids();
  ::dingodb::pb::meta::DingoCommonId* mutable_schema_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::DingoCommonId >*
      mutable_schema_ids();
  private:
  const ::dingodb::pb::meta::DingoCommonId& _internal_schema_ids(int index) const;
  ::dingodb::pb::meta::DingoCommonId* _internal_add_schema_ids();
  public:
  const ::dingodb::pb::meta::DingoCommonId& schema_ids(int index) const;
  ::dingodb::pb::meta::DingoCommonId* add_schema_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::DingoCommonId >&
      schema_ids() const;

  // repeated .dingodb.pb.meta.DingoCommonId table_ids = 4 [json_name = "tableIds"];
  int table_ids_size() const;
  private:
  int _internal_table_ids_size() const;
  public:
  void clear_table_ids();
  ::dingodb::pb::meta::DingoCommonId* mutable_table_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::DingoCommonId >*
      mutable_table_ids();
  private:
  const ::dingodb::pb::meta::DingoCommonId& _internal_table_ids(int index) const;
  ::dingodb::pb::meta::DingoCommonId* _internal_add_table_ids();
  public:
  const ::dingodb::pb::meta::DingoCommonId& table_ids(int index) const;
  ::dingodb::pb::meta::DingoCommonId* add_table_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::DingoCommonId >&
      table_ids() const;

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .dingodb.pb.meta.DingoCommonId id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::dingodb::pb::meta::DingoCommonId& id() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::DingoCommonId* release_id();
  ::dingodb::pb::meta::DingoCommonId* mutable_id();
  void set_allocated_id(::dingodb::pb::meta::DingoCommonId* id);
  private:
  const ::dingodb::pb::meta::DingoCommonId& _internal_id() const;
  ::dingodb::pb::meta::DingoCommonId* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::dingodb::pb::meta::DingoCommonId* id);
  ::dingodb::pb::meta::DingoCommonId* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.Schema)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::DingoCommonId > schema_ids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::DingoCommonId > table_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::dingodb::pb::meta::DingoCommonId* id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class TableDefinition_IndexesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TableDefinition_IndexesEntry_DoNotUse, 
    std::string, ::dingodb::pb::meta::Index,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TableDefinition_IndexesEntry_DoNotUse, 
    std::string, ::dingodb::pb::meta::Index,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TableDefinition_IndexesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TableDefinition_IndexesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TableDefinition_IndexesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TableDefinition_IndexesEntry_DoNotUse& other);
  static const TableDefinition_IndexesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TableDefinition_IndexesEntry_DoNotUse*>(&_TableDefinition_IndexesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "dingodb.pb.meta.TableDefinition.IndexesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_meta_2eproto;
};

// -------------------------------------------------------------------

class TableDefinition_PropertiesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TableDefinition_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TableDefinition_PropertiesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TableDefinition_PropertiesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TableDefinition_PropertiesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TableDefinition_PropertiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TableDefinition_PropertiesEntry_DoNotUse& other);
  static const TableDefinition_PropertiesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TableDefinition_PropertiesEntry_DoNotUse*>(&_TableDefinition_PropertiesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "dingodb.pb.meta.TableDefinition.PropertiesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "dingodb.pb.meta.TableDefinition.PropertiesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_meta_2eproto;
};

// -------------------------------------------------------------------

class TableDefinition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.TableDefinition) */ {
 public:
  inline TableDefinition() : TableDefinition(nullptr) {}
  ~TableDefinition() override;
  explicit PROTOBUF_CONSTEXPR TableDefinition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableDefinition(const TableDefinition& from);
  TableDefinition(TableDefinition&& from) noexcept
    : TableDefinition() {
    *this = ::std::move(from);
  }

  inline TableDefinition& operator=(const TableDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableDefinition& operator=(TableDefinition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableDefinition& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableDefinition* internal_default_instance() {
    return reinterpret_cast<const TableDefinition*>(
               &_TableDefinition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TableDefinition& a, TableDefinition& b) {
    a.Swap(&b);
  }
  inline void Swap(TableDefinition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableDefinition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableDefinition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableDefinition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableDefinition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableDefinition& from) {
    TableDefinition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableDefinition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.TableDefinition";
  }
  protected:
  explicit TableDefinition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 2,
    kIndexesFieldNumber = 3,
    kPropertiesFieldNumber = 8,
    kNameFieldNumber = 1,
    kTablePartitionFieldNumber = 6,
    kTtlFieldNumber = 5,
    kVersionFieldNumber = 4,
    kEngineFieldNumber = 7,
  };
  // repeated .dingodb.pb.meta.ColumnDefinition columns = 2 [json_name = "columns"];
  int columns_size() const;
  private:
  int _internal_columns_size() const;
  public:
  void clear_columns();
  ::dingodb::pb::meta::ColumnDefinition* mutable_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::ColumnDefinition >*
      mutable_columns();
  private:
  const ::dingodb::pb::meta::ColumnDefinition& _internal_columns(int index) const;
  ::dingodb::pb::meta::ColumnDefinition* _internal_add_columns();
  public:
  const ::dingodb::pb::meta::ColumnDefinition& columns(int index) const;
  ::dingodb::pb::meta::ColumnDefinition* add_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::ColumnDefinition >&
      columns() const;

  // map<string, .dingodb.pb.meta.Index> indexes = 3 [json_name = "indexes"];
  int indexes_size() const;
  private:
  int _internal_indexes_size() const;
  public:
  void clear_indexes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::dingodb::pb::meta::Index >&
      _internal_indexes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::dingodb::pb::meta::Index >*
      _internal_mutable_indexes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::dingodb::pb::meta::Index >&
      indexes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::dingodb::pb::meta::Index >*
      mutable_indexes();

  // map<string, string> properties = 8 [json_name = "properties"];
  int properties_size() const;
  private:
  int _internal_properties_size() const;
  public:
  void clear_properties();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_properties();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      properties() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_properties();

  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .dingodb.pb.meta.PartitionRule table_partition = 6 [json_name = "tablePartition"];
  bool has_table_partition() const;
  private:
  bool _internal_has_table_partition() const;
  public:
  void clear_table_partition();
  const ::dingodb::pb::meta::PartitionRule& table_partition() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::PartitionRule* release_table_partition();
  ::dingodb::pb::meta::PartitionRule* mutable_table_partition();
  void set_allocated_table_partition(::dingodb::pb::meta::PartitionRule* table_partition);
  private:
  const ::dingodb::pb::meta::PartitionRule& _internal_table_partition() const;
  ::dingodb::pb::meta::PartitionRule* _internal_mutable_table_partition();
  public:
  void unsafe_arena_set_allocated_table_partition(
      ::dingodb::pb::meta::PartitionRule* table_partition);
  ::dingodb::pb::meta::PartitionRule* unsafe_arena_release_table_partition();

  // uint64 ttl = 5 [json_name = "ttl"];
  void clear_ttl();
  uint64_t ttl() const;
  void set_ttl(uint64_t value);
  private:
  uint64_t _internal_ttl() const;
  void _internal_set_ttl(uint64_t value);
  public:

  // uint32 version = 4 [json_name = "version"];
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // .dingodb.pb.common.Engine engine = 7 [json_name = "engine"];
  void clear_engine();
  ::dingodb::pb::common::Engine engine() const;
  void set_engine(::dingodb::pb::common::Engine value);
  private:
  ::dingodb::pb::common::Engine _internal_engine() const;
  void _internal_set_engine(::dingodb::pb::common::Engine value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.TableDefinition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::ColumnDefinition > columns_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TableDefinition_IndexesEntry_DoNotUse,
        std::string, ::dingodb::pb::meta::Index,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> indexes_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TableDefinition_PropertiesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> properties_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::dingodb::pb::meta::PartitionRule* table_partition_;
    uint64_t ttl_;
    uint32_t version_;
    int engine_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class Part final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.Part) */ {
 public:
  inline Part() : Part(nullptr) {}
  ~Part() override;
  explicit PROTOBUF_CONSTEXPR Part(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Part(const Part& from);
  Part(Part&& from) noexcept
    : Part() {
    *this = ::std::move(from);
  }

  inline Part& operator=(const Part& from) {
    CopyFrom(from);
    return *this;
  }
  inline Part& operator=(Part&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Part& default_instance() {
    return *internal_default_instance();
  }
  static inline const Part* internal_default_instance() {
    return reinterpret_cast<const Part*>(
               &_Part_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Part& a, Part& b) {
    a.Swap(&b);
  }
  inline void Swap(Part* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Part* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Part* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Part>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Part& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Part& from) {
    Part::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Part* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.Part";
  }
  protected:
  explicit Part(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVotersFieldNumber = 4,
    kLearnersFieldNumber = 5,
    kIdFieldNumber = 1,
    kRangeFieldNumber = 2,
    kLeaderFieldNumber = 3,
    kRegionmapEpochFieldNumber = 6,
    kStoremapEpochFieldNumber = 7,
  };
  // repeated .dingodb.pb.common.Location voters = 4 [json_name = "voters"];
  int voters_size() const;
  private:
  int _internal_voters_size() const;
  public:
  void clear_voters();
  ::dingodb::pb::common::Location* mutable_voters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Location >*
      mutable_voters();
  private:
  const ::dingodb::pb::common::Location& _internal_voters(int index) const;
  ::dingodb::pb::common::Location* _internal_add_voters();
  public:
  const ::dingodb::pb::common::Location& voters(int index) const;
  ::dingodb::pb::common::Location* add_voters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Location >&
      voters() const;

  // repeated .dingodb.pb.common.Location learners = 5 [json_name = "learners"];
  int learners_size() const;
  private:
  int _internal_learners_size() const;
  public:
  void clear_learners();
  ::dingodb::pb::common::Location* mutable_learners(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Location >*
      mutable_learners();
  private:
  const ::dingodb::pb::common::Location& _internal_learners(int index) const;
  ::dingodb::pb::common::Location* _internal_add_learners();
  public:
  const ::dingodb::pb::common::Location& learners(int index) const;
  ::dingodb::pb::common::Location* add_learners();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Location >&
      learners() const;

  // .dingodb.pb.meta.DingoCommonId id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::dingodb::pb::meta::DingoCommonId& id() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::DingoCommonId* release_id();
  ::dingodb::pb::meta::DingoCommonId* mutable_id();
  void set_allocated_id(::dingodb::pb::meta::DingoCommonId* id);
  private:
  const ::dingodb::pb::meta::DingoCommonId& _internal_id() const;
  ::dingodb::pb::meta::DingoCommonId* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::dingodb::pb::meta::DingoCommonId* id);
  ::dingodb::pb::meta::DingoCommonId* unsafe_arena_release_id();

  // .dingodb.pb.common.Range range = 2 [json_name = "range"];
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::dingodb::pb::common::Range& range() const;
  PROTOBUF_NODISCARD ::dingodb::pb::common::Range* release_range();
  ::dingodb::pb::common::Range* mutable_range();
  void set_allocated_range(::dingodb::pb::common::Range* range);
  private:
  const ::dingodb::pb::common::Range& _internal_range() const;
  ::dingodb::pb::common::Range* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::dingodb::pb::common::Range* range);
  ::dingodb::pb::common::Range* unsafe_arena_release_range();

  // .dingodb.pb.common.Location leader = 3 [json_name = "leader"];
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const ::dingodb::pb::common::Location& leader() const;
  PROTOBUF_NODISCARD ::dingodb::pb::common::Location* release_leader();
  ::dingodb::pb::common::Location* mutable_leader();
  void set_allocated_leader(::dingodb::pb::common::Location* leader);
  private:
  const ::dingodb::pb::common::Location& _internal_leader() const;
  ::dingodb::pb::common::Location* _internal_mutable_leader();
  public:
  void unsafe_arena_set_allocated_leader(
      ::dingodb::pb::common::Location* leader);
  ::dingodb::pb::common::Location* unsafe_arena_release_leader();

  // uint64 regionmap_epoch = 6 [json_name = "regionmapEpoch"];
  void clear_regionmap_epoch();
  uint64_t regionmap_epoch() const;
  void set_regionmap_epoch(uint64_t value);
  private:
  uint64_t _internal_regionmap_epoch() const;
  void _internal_set_regionmap_epoch(uint64_t value);
  public:

  // uint64 storemap_epoch = 7 [json_name = "storemapEpoch"];
  void clear_storemap_epoch();
  uint64_t storemap_epoch() const;
  void set_storemap_epoch(uint64_t value);
  private:
  uint64_t _internal_storemap_epoch() const;
  void _internal_set_storemap_epoch(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.Part)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Location > voters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Location > learners_;
    ::dingodb::pb::meta::DingoCommonId* id_;
    ::dingodb::pb::common::Range* range_;
    ::dingodb::pb::common::Location* leader_;
    uint64_t regionmap_epoch_;
    uint64_t storemap_epoch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class Table final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.Table) */ {
 public:
  inline Table() : Table(nullptr) {}
  ~Table() override;
  explicit PROTOBUF_CONSTEXPR Table(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Table(const Table& from);
  Table(Table&& from) noexcept
    : Table() {
    *this = ::std::move(from);
  }

  inline Table& operator=(const Table& from) {
    CopyFrom(from);
    return *this;
  }
  inline Table& operator=(Table&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Table& default_instance() {
    return *internal_default_instance();
  }
  static inline const Table* internal_default_instance() {
    return reinterpret_cast<const Table*>(
               &_Table_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Table& a, Table& b) {
    a.Swap(&b);
  }
  inline void Swap(Table* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Table* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Table* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Table>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Table& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Table& from) {
    Table::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Table* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.Table";
  }
  protected:
  explicit Table(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .dingodb.pb.meta.Part parts = 2 [json_name = "parts"];
  int parts_size() const;
  private:
  int _internal_parts_size() const;
  public:
  void clear_parts();
  ::dingodb::pb::meta::Part* mutable_parts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::Part >*
      mutable_parts();
  private:
  const ::dingodb::pb::meta::Part& _internal_parts(int index) const;
  ::dingodb::pb::meta::Part* _internal_add_parts();
  public:
  const ::dingodb::pb::meta::Part& parts(int index) const;
  ::dingodb::pb::meta::Part* add_parts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::Part >&
      parts() const;

  // .dingodb.pb.meta.DingoCommonId id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::dingodb::pb::meta::DingoCommonId& id() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::DingoCommonId* release_id();
  ::dingodb::pb::meta::DingoCommonId* mutable_id();
  void set_allocated_id(::dingodb::pb::meta::DingoCommonId* id);
  private:
  const ::dingodb::pb::meta::DingoCommonId& _internal_id() const;
  ::dingodb::pb::meta::DingoCommonId* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::dingodb::pb::meta::DingoCommonId* id);
  ::dingodb::pb::meta::DingoCommonId* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.Table)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::Part > parts_;
    ::dingodb::pb::meta::DingoCommonId* id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class GetSchemasRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.GetSchemasRequest) */ {
 public:
  inline GetSchemasRequest() : GetSchemasRequest(nullptr) {}
  ~GetSchemasRequest() override;
  explicit PROTOBUF_CONSTEXPR GetSchemasRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSchemasRequest(const GetSchemasRequest& from);
  GetSchemasRequest(GetSchemasRequest&& from) noexcept
    : GetSchemasRequest() {
    *this = ::std::move(from);
  }

  inline GetSchemasRequest& operator=(const GetSchemasRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSchemasRequest& operator=(GetSchemasRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSchemasRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSchemasRequest* internal_default_instance() {
    return reinterpret_cast<const GetSchemasRequest*>(
               &_GetSchemasRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetSchemasRequest& a, GetSchemasRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSchemasRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSchemasRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSchemasRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSchemasRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSchemasRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSchemasRequest& from) {
    GetSchemasRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSchemasRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.GetSchemasRequest";
  }
  protected:
  explicit GetSchemasRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaIdFieldNumber = 1,
  };
  // .dingodb.pb.meta.DingoCommonId schema_id = 1 [json_name = "schemaId"];
  bool has_schema_id() const;
  private:
  bool _internal_has_schema_id() const;
  public:
  void clear_schema_id();
  const ::dingodb::pb::meta::DingoCommonId& schema_id() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::DingoCommonId* release_schema_id();
  ::dingodb::pb::meta::DingoCommonId* mutable_schema_id();
  void set_allocated_schema_id(::dingodb::pb::meta::DingoCommonId* schema_id);
  private:
  const ::dingodb::pb::meta::DingoCommonId& _internal_schema_id() const;
  ::dingodb::pb::meta::DingoCommonId* _internal_mutable_schema_id();
  public:
  void unsafe_arena_set_allocated_schema_id(
      ::dingodb::pb::meta::DingoCommonId* schema_id);
  ::dingodb::pb::meta::DingoCommonId* unsafe_arena_release_schema_id();

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.GetSchemasRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dingodb::pb::meta::DingoCommonId* schema_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class GetSchemasResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.GetSchemasResponse) */ {
 public:
  inline GetSchemasResponse() : GetSchemasResponse(nullptr) {}
  ~GetSchemasResponse() override;
  explicit PROTOBUF_CONSTEXPR GetSchemasResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSchemasResponse(const GetSchemasResponse& from);
  GetSchemasResponse(GetSchemasResponse&& from) noexcept
    : GetSchemasResponse() {
    *this = ::std::move(from);
  }

  inline GetSchemasResponse& operator=(const GetSchemasResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSchemasResponse& operator=(GetSchemasResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSchemasResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSchemasResponse* internal_default_instance() {
    return reinterpret_cast<const GetSchemasResponse*>(
               &_GetSchemasResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetSchemasResponse& a, GetSchemasResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSchemasResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSchemasResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSchemasResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSchemasResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSchemasResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSchemasResponse& from) {
    GetSchemasResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSchemasResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.GetSchemasResponse";
  }
  protected:
  explicit GetSchemasResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemasFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // repeated .dingodb.pb.meta.Schema schemas = 2 [json_name = "schemas"];
  int schemas_size() const;
  private:
  int _internal_schemas_size() const;
  public:
  void clear_schemas();
  ::dingodb::pb::meta::Schema* mutable_schemas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::Schema >*
      mutable_schemas();
  private:
  const ::dingodb::pb::meta::Schema& _internal_schemas(int index) const;
  ::dingodb::pb::meta::Schema* _internal_add_schemas();
  public:
  const ::dingodb::pb::meta::Schema& schemas(int index) const;
  ::dingodb::pb::meta::Schema* add_schemas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::Schema >&
      schemas() const;

  // .dingodb.pb.error.Error error = 1 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::dingodb::pb::error::Error& error() const;
  PROTOBUF_NODISCARD ::dingodb::pb::error::Error* release_error();
  ::dingodb::pb::error::Error* mutable_error();
  void set_allocated_error(::dingodb::pb::error::Error* error);
  private:
  const ::dingodb::pb::error::Error& _internal_error() const;
  ::dingodb::pb::error::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::dingodb::pb::error::Error* error);
  ::dingodb::pb::error::Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.GetSchemasResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::Schema > schemas_;
    ::dingodb::pb::error::Error* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class TableDefinitionWithId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.TableDefinitionWithId) */ {
 public:
  inline TableDefinitionWithId() : TableDefinitionWithId(nullptr) {}
  ~TableDefinitionWithId() override;
  explicit PROTOBUF_CONSTEXPR TableDefinitionWithId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableDefinitionWithId(const TableDefinitionWithId& from);
  TableDefinitionWithId(TableDefinitionWithId&& from) noexcept
    : TableDefinitionWithId() {
    *this = ::std::move(from);
  }

  inline TableDefinitionWithId& operator=(const TableDefinitionWithId& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableDefinitionWithId& operator=(TableDefinitionWithId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableDefinitionWithId& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableDefinitionWithId* internal_default_instance() {
    return reinterpret_cast<const TableDefinitionWithId*>(
               &_TableDefinitionWithId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TableDefinitionWithId& a, TableDefinitionWithId& b) {
    a.Swap(&b);
  }
  inline void Swap(TableDefinitionWithId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableDefinitionWithId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableDefinitionWithId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableDefinitionWithId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableDefinitionWithId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableDefinitionWithId& from) {
    TableDefinitionWithId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableDefinitionWithId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.TableDefinitionWithId";
  }
  protected:
  explicit TableDefinitionWithId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableIdFieldNumber = 1,
    kTableDefinitionFieldNumber = 2,
  };
  // .dingodb.pb.meta.DingoCommonId table_id = 1 [json_name = "tableId"];
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  const ::dingodb::pb::meta::DingoCommonId& table_id() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::DingoCommonId* release_table_id();
  ::dingodb::pb::meta::DingoCommonId* mutable_table_id();
  void set_allocated_table_id(::dingodb::pb::meta::DingoCommonId* table_id);
  private:
  const ::dingodb::pb::meta::DingoCommonId& _internal_table_id() const;
  ::dingodb::pb::meta::DingoCommonId* _internal_mutable_table_id();
  public:
  void unsafe_arena_set_allocated_table_id(
      ::dingodb::pb::meta::DingoCommonId* table_id);
  ::dingodb::pb::meta::DingoCommonId* unsafe_arena_release_table_id();

  // .dingodb.pb.meta.TableDefinition table_definition = 2 [json_name = "tableDefinition"];
  bool has_table_definition() const;
  private:
  bool _internal_has_table_definition() const;
  public:
  void clear_table_definition();
  const ::dingodb::pb::meta::TableDefinition& table_definition() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::TableDefinition* release_table_definition();
  ::dingodb::pb::meta::TableDefinition* mutable_table_definition();
  void set_allocated_table_definition(::dingodb::pb::meta::TableDefinition* table_definition);
  private:
  const ::dingodb::pb::meta::TableDefinition& _internal_table_definition() const;
  ::dingodb::pb::meta::TableDefinition* _internal_mutable_table_definition();
  public:
  void unsafe_arena_set_allocated_table_definition(
      ::dingodb::pb::meta::TableDefinition* table_definition);
  ::dingodb::pb::meta::TableDefinition* unsafe_arena_release_table_definition();

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.TableDefinitionWithId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dingodb::pb::meta::DingoCommonId* table_id_;
    ::dingodb::pb::meta::TableDefinition* table_definition_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class GetTablesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.GetTablesRequest) */ {
 public:
  inline GetTablesRequest() : GetTablesRequest(nullptr) {}
  ~GetTablesRequest() override;
  explicit PROTOBUF_CONSTEXPR GetTablesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTablesRequest(const GetTablesRequest& from);
  GetTablesRequest(GetTablesRequest&& from) noexcept
    : GetTablesRequest() {
    *this = ::std::move(from);
  }

  inline GetTablesRequest& operator=(const GetTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTablesRequest& operator=(GetTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTablesRequest* internal_default_instance() {
    return reinterpret_cast<const GetTablesRequest*>(
               &_GetTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetTablesRequest& a, GetTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTablesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTablesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTablesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTablesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTablesRequest& from) {
    GetTablesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTablesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.GetTablesRequest";
  }
  protected:
  explicit GetTablesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaIdFieldNumber = 1,
  };
  // .dingodb.pb.meta.DingoCommonId schema_id = 1 [json_name = "schemaId"];
  bool has_schema_id() const;
  private:
  bool _internal_has_schema_id() const;
  public:
  void clear_schema_id();
  const ::dingodb::pb::meta::DingoCommonId& schema_id() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::DingoCommonId* release_schema_id();
  ::dingodb::pb::meta::DingoCommonId* mutable_schema_id();
  void set_allocated_schema_id(::dingodb::pb::meta::DingoCommonId* schema_id);
  private:
  const ::dingodb::pb::meta::DingoCommonId& _internal_schema_id() const;
  ::dingodb::pb::meta::DingoCommonId* _internal_mutable_schema_id();
  public:
  void unsafe_arena_set_allocated_schema_id(
      ::dingodb::pb::meta::DingoCommonId* schema_id);
  ::dingodb::pb::meta::DingoCommonId* unsafe_arena_release_schema_id();

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.GetTablesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dingodb::pb::meta::DingoCommonId* schema_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class GetTablesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.GetTablesResponse) */ {
 public:
  inline GetTablesResponse() : GetTablesResponse(nullptr) {}
  ~GetTablesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetTablesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTablesResponse(const GetTablesResponse& from);
  GetTablesResponse(GetTablesResponse&& from) noexcept
    : GetTablesResponse() {
    *this = ::std::move(from);
  }

  inline GetTablesResponse& operator=(const GetTablesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTablesResponse& operator=(GetTablesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTablesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTablesResponse* internal_default_instance() {
    return reinterpret_cast<const GetTablesResponse*>(
               &_GetTablesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetTablesResponse& a, GetTablesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTablesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTablesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTablesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTablesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTablesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTablesResponse& from) {
    GetTablesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTablesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.GetTablesResponse";
  }
  protected:
  explicit GetTablesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableDefinitionWithIdsFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // repeated .dingodb.pb.meta.TableDefinitionWithId table_definition_with_ids = 2 [json_name = "tableDefinitionWithIds"];
  int table_definition_with_ids_size() const;
  private:
  int _internal_table_definition_with_ids_size() const;
  public:
  void clear_table_definition_with_ids();
  ::dingodb::pb::meta::TableDefinitionWithId* mutable_table_definition_with_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::TableDefinitionWithId >*
      mutable_table_definition_with_ids();
  private:
  const ::dingodb::pb::meta::TableDefinitionWithId& _internal_table_definition_with_ids(int index) const;
  ::dingodb::pb::meta::TableDefinitionWithId* _internal_add_table_definition_with_ids();
  public:
  const ::dingodb::pb::meta::TableDefinitionWithId& table_definition_with_ids(int index) const;
  ::dingodb::pb::meta::TableDefinitionWithId* add_table_definition_with_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::TableDefinitionWithId >&
      table_definition_with_ids() const;

  // .dingodb.pb.error.Error error = 1 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::dingodb::pb::error::Error& error() const;
  PROTOBUF_NODISCARD ::dingodb::pb::error::Error* release_error();
  ::dingodb::pb::error::Error* mutable_error();
  void set_allocated_error(::dingodb::pb::error::Error* error);
  private:
  const ::dingodb::pb::error::Error& _internal_error() const;
  ::dingodb::pb::error::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::dingodb::pb::error::Error* error);
  ::dingodb::pb::error::Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.GetTablesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::TableDefinitionWithId > table_definition_with_ids_;
    ::dingodb::pb::error::Error* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class GetTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.GetTableRequest) */ {
 public:
  inline GetTableRequest() : GetTableRequest(nullptr) {}
  ~GetTableRequest() override;
  explicit PROTOBUF_CONSTEXPR GetTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTableRequest(const GetTableRequest& from);
  GetTableRequest(GetTableRequest&& from) noexcept
    : GetTableRequest() {
    *this = ::std::move(from);
  }

  inline GetTableRequest& operator=(const GetTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTableRequest& operator=(GetTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTableRequest* internal_default_instance() {
    return reinterpret_cast<const GetTableRequest*>(
               &_GetTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetTableRequest& a, GetTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTableRequest& from) {
    GetTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.GetTableRequest";
  }
  protected:
  explicit GetTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableIdFieldNumber = 1,
  };
  // .dingodb.pb.meta.DingoCommonId table_id = 1 [json_name = "tableId"];
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  const ::dingodb::pb::meta::DingoCommonId& table_id() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::DingoCommonId* release_table_id();
  ::dingodb::pb::meta::DingoCommonId* mutable_table_id();
  void set_allocated_table_id(::dingodb::pb::meta::DingoCommonId* table_id);
  private:
  const ::dingodb::pb::meta::DingoCommonId& _internal_table_id() const;
  ::dingodb::pb::meta::DingoCommonId* _internal_mutable_table_id();
  public:
  void unsafe_arena_set_allocated_table_id(
      ::dingodb::pb::meta::DingoCommonId* table_id);
  ::dingodb::pb::meta::DingoCommonId* unsafe_arena_release_table_id();

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.GetTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dingodb::pb::meta::DingoCommonId* table_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class GetTableResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.GetTableResponse) */ {
 public:
  inline GetTableResponse() : GetTableResponse(nullptr) {}
  ~GetTableResponse() override;
  explicit PROTOBUF_CONSTEXPR GetTableResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTableResponse(const GetTableResponse& from);
  GetTableResponse(GetTableResponse&& from) noexcept
    : GetTableResponse() {
    *this = ::std::move(from);
  }

  inline GetTableResponse& operator=(const GetTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTableResponse& operator=(GetTableResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTableResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTableResponse* internal_default_instance() {
    return reinterpret_cast<const GetTableResponse*>(
               &_GetTableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetTableResponse& a, GetTableResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTableResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTableResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTableResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTableResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTableResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTableResponse& from) {
    GetTableResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTableResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.GetTableResponse";
  }
  protected:
  explicit GetTableResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kTableFieldNumber = 2,
  };
  // .dingodb.pb.error.Error error = 1 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::dingodb::pb::error::Error& error() const;
  PROTOBUF_NODISCARD ::dingodb::pb::error::Error* release_error();
  ::dingodb::pb::error::Error* mutable_error();
  void set_allocated_error(::dingodb::pb::error::Error* error);
  private:
  const ::dingodb::pb::error::Error& _internal_error() const;
  ::dingodb::pb::error::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::dingodb::pb::error::Error* error);
  ::dingodb::pb::error::Error* unsafe_arena_release_error();

  // .dingodb.pb.meta.Table table = 2 [json_name = "table"];
  bool has_table() const;
  private:
  bool _internal_has_table() const;
  public:
  void clear_table();
  const ::dingodb::pb::meta::Table& table() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::Table* release_table();
  ::dingodb::pb::meta::Table* mutable_table();
  void set_allocated_table(::dingodb::pb::meta::Table* table);
  private:
  const ::dingodb::pb::meta::Table& _internal_table() const;
  ::dingodb::pb::meta::Table* _internal_mutable_table();
  public:
  void unsafe_arena_set_allocated_table(
      ::dingodb::pb::meta::Table* table);
  ::dingodb::pb::meta::Table* unsafe_arena_release_table();

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.GetTableResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dingodb::pb::error::Error* error_;
    ::dingodb::pb::meta::Table* table_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class CreateTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.CreateTableRequest) */ {
 public:
  inline CreateTableRequest() : CreateTableRequest(nullptr) {}
  ~CreateTableRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTableRequest(const CreateTableRequest& from);
  CreateTableRequest(CreateTableRequest&& from) noexcept
    : CreateTableRequest() {
    *this = ::std::move(from);
  }

  inline CreateTableRequest& operator=(const CreateTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTableRequest& operator=(CreateTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTableRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTableRequest*>(
               &_CreateTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CreateTableRequest& a, CreateTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateTableRequest& from) {
    CreateTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.CreateTableRequest";
  }
  protected:
  explicit CreateTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaIdFieldNumber = 1,
    kTableDefinitionFieldNumber = 2,
  };
  // .dingodb.pb.meta.DingoCommonId schema_id = 1 [json_name = "schemaId"];
  bool has_schema_id() const;
  private:
  bool _internal_has_schema_id() const;
  public:
  void clear_schema_id();
  const ::dingodb::pb::meta::DingoCommonId& schema_id() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::DingoCommonId* release_schema_id();
  ::dingodb::pb::meta::DingoCommonId* mutable_schema_id();
  void set_allocated_schema_id(::dingodb::pb::meta::DingoCommonId* schema_id);
  private:
  const ::dingodb::pb::meta::DingoCommonId& _internal_schema_id() const;
  ::dingodb::pb::meta::DingoCommonId* _internal_mutable_schema_id();
  public:
  void unsafe_arena_set_allocated_schema_id(
      ::dingodb::pb::meta::DingoCommonId* schema_id);
  ::dingodb::pb::meta::DingoCommonId* unsafe_arena_release_schema_id();

  // .dingodb.pb.meta.TableDefinition table_definition = 2 [json_name = "tableDefinition"];
  bool has_table_definition() const;
  private:
  bool _internal_has_table_definition() const;
  public:
  void clear_table_definition();
  const ::dingodb::pb::meta::TableDefinition& table_definition() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::TableDefinition* release_table_definition();
  ::dingodb::pb::meta::TableDefinition* mutable_table_definition();
  void set_allocated_table_definition(::dingodb::pb::meta::TableDefinition* table_definition);
  private:
  const ::dingodb::pb::meta::TableDefinition& _internal_table_definition() const;
  ::dingodb::pb::meta::TableDefinition* _internal_mutable_table_definition();
  public:
  void unsafe_arena_set_allocated_table_definition(
      ::dingodb::pb::meta::TableDefinition* table_definition);
  ::dingodb::pb::meta::TableDefinition* unsafe_arena_release_table_definition();

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.CreateTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dingodb::pb::meta::DingoCommonId* schema_id_;
    ::dingodb::pb::meta::TableDefinition* table_definition_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class CreateTableResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.CreateTableResponse) */ {
 public:
  inline CreateTableResponse() : CreateTableResponse(nullptr) {}
  ~CreateTableResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateTableResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTableResponse(const CreateTableResponse& from);
  CreateTableResponse(CreateTableResponse&& from) noexcept
    : CreateTableResponse() {
    *this = ::std::move(from);
  }

  inline CreateTableResponse& operator=(const CreateTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTableResponse& operator=(CreateTableResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTableResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTableResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTableResponse*>(
               &_CreateTableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CreateTableResponse& a, CreateTableResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTableResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTableResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTableResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTableResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTableResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateTableResponse& from) {
    CreateTableResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTableResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.CreateTableResponse";
  }
  protected:
  explicit CreateTableResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kTableFieldNumber = 2,
  };
  // .dingodb.pb.error.Error error = 1 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::dingodb::pb::error::Error& error() const;
  PROTOBUF_NODISCARD ::dingodb::pb::error::Error* release_error();
  ::dingodb::pb::error::Error* mutable_error();
  void set_allocated_error(::dingodb::pb::error::Error* error);
  private:
  const ::dingodb::pb::error::Error& _internal_error() const;
  ::dingodb::pb::error::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::dingodb::pb::error::Error* error);
  ::dingodb::pb::error::Error* unsafe_arena_release_error();

  // .dingodb.pb.meta.Table table = 2 [json_name = "table"];
  bool has_table() const;
  private:
  bool _internal_has_table() const;
  public:
  void clear_table();
  const ::dingodb::pb::meta::Table& table() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::Table* release_table();
  ::dingodb::pb::meta::Table* mutable_table();
  void set_allocated_table(::dingodb::pb::meta::Table* table);
  private:
  const ::dingodb::pb::meta::Table& _internal_table() const;
  ::dingodb::pb::meta::Table* _internal_mutable_table();
  public:
  void unsafe_arena_set_allocated_table(
      ::dingodb::pb::meta::Table* table);
  ::dingodb::pb::meta::Table* unsafe_arena_release_table();

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.CreateTableResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dingodb::pb::error::Error* error_;
    ::dingodb::pb::meta::Table* table_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class CreateSchemaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.CreateSchemaRequest) */ {
 public:
  inline CreateSchemaRequest() : CreateSchemaRequest(nullptr) {}
  ~CreateSchemaRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateSchemaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSchemaRequest(const CreateSchemaRequest& from);
  CreateSchemaRequest(CreateSchemaRequest&& from) noexcept
    : CreateSchemaRequest() {
    *this = ::std::move(from);
  }

  inline CreateSchemaRequest& operator=(const CreateSchemaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSchemaRequest& operator=(CreateSchemaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSchemaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSchemaRequest* internal_default_instance() {
    return reinterpret_cast<const CreateSchemaRequest*>(
               &_CreateSchemaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CreateSchemaRequest& a, CreateSchemaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSchemaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSchemaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSchemaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSchemaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSchemaRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateSchemaRequest& from) {
    CreateSchemaRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSchemaRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.CreateSchemaRequest";
  }
  protected:
  explicit CreateSchemaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaNameFieldNumber = 2,
    kParentSchemaIdFieldNumber = 1,
  };
  // string schema_name = 2 [json_name = "schemaName"];
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // .dingodb.pb.meta.DingoCommonId parent_schema_id = 1 [json_name = "parentSchemaId"];
  bool has_parent_schema_id() const;
  private:
  bool _internal_has_parent_schema_id() const;
  public:
  void clear_parent_schema_id();
  const ::dingodb::pb::meta::DingoCommonId& parent_schema_id() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::DingoCommonId* release_parent_schema_id();
  ::dingodb::pb::meta::DingoCommonId* mutable_parent_schema_id();
  void set_allocated_parent_schema_id(::dingodb::pb::meta::DingoCommonId* parent_schema_id);
  private:
  const ::dingodb::pb::meta::DingoCommonId& _internal_parent_schema_id() const;
  ::dingodb::pb::meta::DingoCommonId* _internal_mutable_parent_schema_id();
  public:
  void unsafe_arena_set_allocated_parent_schema_id(
      ::dingodb::pb::meta::DingoCommonId* parent_schema_id);
  ::dingodb::pb::meta::DingoCommonId* unsafe_arena_release_parent_schema_id();

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.CreateSchemaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::dingodb::pb::meta::DingoCommonId* parent_schema_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class CreateSchemaResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.CreateSchemaResponse) */ {
 public:
  inline CreateSchemaResponse() : CreateSchemaResponse(nullptr) {}
  ~CreateSchemaResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateSchemaResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSchemaResponse(const CreateSchemaResponse& from);
  CreateSchemaResponse(CreateSchemaResponse&& from) noexcept
    : CreateSchemaResponse() {
    *this = ::std::move(from);
  }

  inline CreateSchemaResponse& operator=(const CreateSchemaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSchemaResponse& operator=(CreateSchemaResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSchemaResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSchemaResponse* internal_default_instance() {
    return reinterpret_cast<const CreateSchemaResponse*>(
               &_CreateSchemaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CreateSchemaResponse& a, CreateSchemaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSchemaResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSchemaResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSchemaResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSchemaResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSchemaResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateSchemaResponse& from) {
    CreateSchemaResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSchemaResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.CreateSchemaResponse";
  }
  protected:
  explicit CreateSchemaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kSchemaFieldNumber = 2,
  };
  // .dingodb.pb.error.Error error = 1 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::dingodb::pb::error::Error& error() const;
  PROTOBUF_NODISCARD ::dingodb::pb::error::Error* release_error();
  ::dingodb::pb::error::Error* mutable_error();
  void set_allocated_error(::dingodb::pb::error::Error* error);
  private:
  const ::dingodb::pb::error::Error& _internal_error() const;
  ::dingodb::pb::error::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::dingodb::pb::error::Error* error);
  ::dingodb::pb::error::Error* unsafe_arena_release_error();

  // .dingodb.pb.meta.Schema schema = 2 [json_name = "schema"];
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::dingodb::pb::meta::Schema& schema() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::Schema* release_schema();
  ::dingodb::pb::meta::Schema* mutable_schema();
  void set_allocated_schema(::dingodb::pb::meta::Schema* schema);
  private:
  const ::dingodb::pb::meta::Schema& _internal_schema() const;
  ::dingodb::pb::meta::Schema* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::dingodb::pb::meta::Schema* schema);
  ::dingodb::pb::meta::Schema* unsafe_arena_release_schema();

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.CreateSchemaResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dingodb::pb::error::Error* error_;
    ::dingodb::pb::meta::Schema* schema_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class DropTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.DropTableRequest) */ {
 public:
  inline DropTableRequest() : DropTableRequest(nullptr) {}
  ~DropTableRequest() override;
  explicit PROTOBUF_CONSTEXPR DropTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropTableRequest(const DropTableRequest& from);
  DropTableRequest(DropTableRequest&& from) noexcept
    : DropTableRequest() {
    *this = ::std::move(from);
  }

  inline DropTableRequest& operator=(const DropTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropTableRequest& operator=(DropTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropTableRequest* internal_default_instance() {
    return reinterpret_cast<const DropTableRequest*>(
               &_DropTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(DropTableRequest& a, DropTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DropTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropTableRequest& from) {
    DropTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.DropTableRequest";
  }
  protected:
  explicit DropTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableIdFieldNumber = 1,
  };
  // .dingodb.pb.meta.DingoCommonId table_id = 1 [json_name = "tableId"];
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  const ::dingodb::pb::meta::DingoCommonId& table_id() const;
  PROTOBUF_NODISCARD ::dingodb::pb::meta::DingoCommonId* release_table_id();
  ::dingodb::pb::meta::DingoCommonId* mutable_table_id();
  void set_allocated_table_id(::dingodb::pb::meta::DingoCommonId* table_id);
  private:
  const ::dingodb::pb::meta::DingoCommonId& _internal_table_id() const;
  ::dingodb::pb::meta::DingoCommonId* _internal_mutable_table_id();
  public:
  void unsafe_arena_set_allocated_table_id(
      ::dingodb::pb::meta::DingoCommonId* table_id);
  ::dingodb::pb::meta::DingoCommonId* unsafe_arena_release_table_id();

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.DropTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dingodb::pb::meta::DingoCommonId* table_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// -------------------------------------------------------------------

class DropTableResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.meta.DropTableResponse) */ {
 public:
  inline DropTableResponse() : DropTableResponse(nullptr) {}
  ~DropTableResponse() override;
  explicit PROTOBUF_CONSTEXPR DropTableResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropTableResponse(const DropTableResponse& from);
  DropTableResponse(DropTableResponse&& from) noexcept
    : DropTableResponse() {
    *this = ::std::move(from);
  }

  inline DropTableResponse& operator=(const DropTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropTableResponse& operator=(DropTableResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropTableResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropTableResponse* internal_default_instance() {
    return reinterpret_cast<const DropTableResponse*>(
               &_DropTableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(DropTableResponse& a, DropTableResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DropTableResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropTableResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropTableResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropTableResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropTableResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropTableResponse& from) {
    DropTableResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropTableResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.meta.DropTableResponse";
  }
  protected:
  explicit DropTableResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // .dingodb.pb.error.Error error = 1 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::dingodb::pb::error::Error& error() const;
  PROTOBUF_NODISCARD ::dingodb::pb::error::Error* release_error();
  ::dingodb::pb::error::Error* mutable_error();
  void set_allocated_error(::dingodb::pb::error::Error* error);
  private:
  const ::dingodb::pb::error::Error& _internal_error() const;
  ::dingodb::pb::error::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::dingodb::pb::error::Error* error);
  ::dingodb::pb::error::Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:dingodb.pb.meta.DropTableResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dingodb::pb::error::Error* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_meta_2eproto;
};
// ===================================================================

class MetaService_Stub;

class MetaService : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline MetaService() {};
 public:
  virtual ~MetaService();

  typedef MetaService_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void GetSchemas(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::meta::GetSchemasRequest* request,
                       ::dingodb::pb::meta::GetSchemasResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void GetTables(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::meta::GetTablesRequest* request,
                       ::dingodb::pb::meta::GetTablesResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void GetTable(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::meta::GetTableRequest* request,
                       ::dingodb::pb::meta::GetTableResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void CreateTable(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::meta::CreateTableRequest* request,
                       ::dingodb::pb::meta::CreateTableResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void DropTable(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::meta::DropTableRequest* request,
                       ::dingodb::pb::meta::DropTableResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void CreateSchema(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::meta::CreateSchemaRequest* request,
                       ::dingodb::pb::meta::CreateSchemaResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MetaService);
};

class MetaService_Stub : public MetaService {
 public:
  MetaService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  MetaService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~MetaService_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements MetaService ------------------------------------------

  void GetSchemas(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::meta::GetSchemasRequest* request,
                       ::dingodb::pb::meta::GetSchemasResponse* response,
                       ::google::protobuf::Closure* done);
  void GetTables(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::meta::GetTablesRequest* request,
                       ::dingodb::pb::meta::GetTablesResponse* response,
                       ::google::protobuf::Closure* done);
  void GetTable(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::meta::GetTableRequest* request,
                       ::dingodb::pb::meta::GetTableResponse* response,
                       ::google::protobuf::Closure* done);
  void CreateTable(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::meta::CreateTableRequest* request,
                       ::dingodb::pb::meta::CreateTableResponse* response,
                       ::google::protobuf::Closure* done);
  void DropTable(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::meta::DropTableRequest* request,
                       ::dingodb::pb::meta::DropTableResponse* response,
                       ::google::protobuf::Closure* done);
  void CreateSchema(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::meta::CreateSchemaRequest* request,
                       ::dingodb::pb::meta::CreateSchemaResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MetaService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DingoCommonId

// .dingodb.pb.meta.EntityType entity_type = 1 [json_name = "entityType"];
inline void DingoCommonId::clear_entity_type() {
  _impl_.entity_type_ = 0;
}
inline ::dingodb::pb::meta::EntityType DingoCommonId::_internal_entity_type() const {
  return static_cast< ::dingodb::pb::meta::EntityType >(_impl_.entity_type_);
}
inline ::dingodb::pb::meta::EntityType DingoCommonId::entity_type() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.DingoCommonId.entity_type)
  return _internal_entity_type();
}
inline void DingoCommonId::_internal_set_entity_type(::dingodb::pb::meta::EntityType value) {
  
  _impl_.entity_type_ = value;
}
inline void DingoCommonId::set_entity_type(::dingodb::pb::meta::EntityType value) {
  _internal_set_entity_type(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.DingoCommonId.entity_type)
}

// uint64 parent_entity_id = 2 [json_name = "parentEntityId"];
inline void DingoCommonId::clear_parent_entity_id() {
  _impl_.parent_entity_id_ = uint64_t{0u};
}
inline uint64_t DingoCommonId::_internal_parent_entity_id() const {
  return _impl_.parent_entity_id_;
}
inline uint64_t DingoCommonId::parent_entity_id() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.DingoCommonId.parent_entity_id)
  return _internal_parent_entity_id();
}
inline void DingoCommonId::_internal_set_parent_entity_id(uint64_t value) {
  
  _impl_.parent_entity_id_ = value;
}
inline void DingoCommonId::set_parent_entity_id(uint64_t value) {
  _internal_set_parent_entity_id(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.DingoCommonId.parent_entity_id)
}

// uint64 entity_id = 3 [json_name = "entityId"];
inline void DingoCommonId::clear_entity_id() {
  _impl_.entity_id_ = uint64_t{0u};
}
inline uint64_t DingoCommonId::_internal_entity_id() const {
  return _impl_.entity_id_;
}
inline uint64_t DingoCommonId::entity_id() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.DingoCommonId.entity_id)
  return _internal_entity_id();
}
inline void DingoCommonId::_internal_set_entity_id(uint64_t value) {
  
  _impl_.entity_id_ = value;
}
inline void DingoCommonId::set_entity_id(uint64_t value) {
  _internal_set_entity_id(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.DingoCommonId.entity_id)
}

// -------------------------------------------------------------------

// ColumnDefinition

// string name = 1 [json_name = "name"];
inline void ColumnDefinition::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ColumnDefinition::name() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.ColumnDefinition.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnDefinition::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.ColumnDefinition.name)
}
inline std::string* ColumnDefinition::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.ColumnDefinition.name)
  return _s;
}
inline const std::string& ColumnDefinition::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ColumnDefinition::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnDefinition::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnDefinition::release_name() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.ColumnDefinition.name)
  return _impl_.name_.Release();
}
inline void ColumnDefinition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.ColumnDefinition.name)
}

// .dingodb.pb.meta.SqlType sql_type = 2 [json_name = "sqlType"];
inline void ColumnDefinition::clear_sql_type() {
  _impl_.sql_type_ = 0;
}
inline ::dingodb::pb::meta::SqlType ColumnDefinition::_internal_sql_type() const {
  return static_cast< ::dingodb::pb::meta::SqlType >(_impl_.sql_type_);
}
inline ::dingodb::pb::meta::SqlType ColumnDefinition::sql_type() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.ColumnDefinition.sql_type)
  return _internal_sql_type();
}
inline void ColumnDefinition::_internal_set_sql_type(::dingodb::pb::meta::SqlType value) {
  
  _impl_.sql_type_ = value;
}
inline void ColumnDefinition::set_sql_type(::dingodb::pb::meta::SqlType value) {
  _internal_set_sql_type(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.ColumnDefinition.sql_type)
}

// .dingodb.pb.meta.ElementType element_type = 3 [json_name = "elementType"];
inline void ColumnDefinition::clear_element_type() {
  _impl_.element_type_ = 0;
}
inline ::dingodb::pb::meta::ElementType ColumnDefinition::_internal_element_type() const {
  return static_cast< ::dingodb::pb::meta::ElementType >(_impl_.element_type_);
}
inline ::dingodb::pb::meta::ElementType ColumnDefinition::element_type() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.ColumnDefinition.element_type)
  return _internal_element_type();
}
inline void ColumnDefinition::_internal_set_element_type(::dingodb::pb::meta::ElementType value) {
  
  _impl_.element_type_ = value;
}
inline void ColumnDefinition::set_element_type(::dingodb::pb::meta::ElementType value) {
  _internal_set_element_type(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.ColumnDefinition.element_type)
}

// int32 precision = 4 [json_name = "precision"];
inline void ColumnDefinition::clear_precision() {
  _impl_.precision_ = 0;
}
inline int32_t ColumnDefinition::_internal_precision() const {
  return _impl_.precision_;
}
inline int32_t ColumnDefinition::precision() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.ColumnDefinition.precision)
  return _internal_precision();
}
inline void ColumnDefinition::_internal_set_precision(int32_t value) {
  
  _impl_.precision_ = value;
}
inline void ColumnDefinition::set_precision(int32_t value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.ColumnDefinition.precision)
}

// int32 scale = 5 [json_name = "scale"];
inline void ColumnDefinition::clear_scale() {
  _impl_.scale_ = 0;
}
inline int32_t ColumnDefinition::_internal_scale() const {
  return _impl_.scale_;
}
inline int32_t ColumnDefinition::scale() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.ColumnDefinition.scale)
  return _internal_scale();
}
inline void ColumnDefinition::_internal_set_scale(int32_t value) {
  
  _impl_.scale_ = value;
}
inline void ColumnDefinition::set_scale(int32_t value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.ColumnDefinition.scale)
}

// bool nullable = 6 [json_name = "nullable"];
inline void ColumnDefinition::clear_nullable() {
  _impl_.nullable_ = false;
}
inline bool ColumnDefinition::_internal_nullable() const {
  return _impl_.nullable_;
}
inline bool ColumnDefinition::nullable() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.ColumnDefinition.nullable)
  return _internal_nullable();
}
inline void ColumnDefinition::_internal_set_nullable(bool value) {
  
  _impl_.nullable_ = value;
}
inline void ColumnDefinition::set_nullable(bool value) {
  _internal_set_nullable(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.ColumnDefinition.nullable)
}

// int32 indexOfKey = 7 [json_name = "indexOfKey"];
inline void ColumnDefinition::clear_indexofkey() {
  _impl_.indexofkey_ = 0;
}
inline int32_t ColumnDefinition::_internal_indexofkey() const {
  return _impl_.indexofkey_;
}
inline int32_t ColumnDefinition::indexofkey() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.ColumnDefinition.indexOfKey)
  return _internal_indexofkey();
}
inline void ColumnDefinition::_internal_set_indexofkey(int32_t value) {
  
  _impl_.indexofkey_ = value;
}
inline void ColumnDefinition::set_indexofkey(int32_t value) {
  _internal_set_indexofkey(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.ColumnDefinition.indexOfKey)
}

// bool has_default_val = 8 [json_name = "hasDefaultVal"];
inline void ColumnDefinition::clear_has_default_val() {
  _impl_.has_default_val_ = false;
}
inline bool ColumnDefinition::_internal_has_default_val() const {
  return _impl_.has_default_val_;
}
inline bool ColumnDefinition::has_default_val() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.ColumnDefinition.has_default_val)
  return _internal_has_default_val();
}
inline void ColumnDefinition::_internal_set_has_default_val(bool value) {
  
  _impl_.has_default_val_ = value;
}
inline void ColumnDefinition::set_has_default_val(bool value) {
  _internal_set_has_default_val(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.ColumnDefinition.has_default_val)
}

// string default_val = 9 [json_name = "defaultVal"];
inline void ColumnDefinition::clear_default_val() {
  _impl_.default_val_.ClearToEmpty();
}
inline const std::string& ColumnDefinition::default_val() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.ColumnDefinition.default_val)
  return _internal_default_val();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnDefinition::set_default_val(ArgT0&& arg0, ArgT... args) {
 
 _impl_.default_val_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.ColumnDefinition.default_val)
}
inline std::string* ColumnDefinition::mutable_default_val() {
  std::string* _s = _internal_mutable_default_val();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.ColumnDefinition.default_val)
  return _s;
}
inline const std::string& ColumnDefinition::_internal_default_val() const {
  return _impl_.default_val_.Get();
}
inline void ColumnDefinition::_internal_set_default_val(const std::string& value) {
  
  _impl_.default_val_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnDefinition::_internal_mutable_default_val() {
  
  return _impl_.default_val_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnDefinition::release_default_val() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.ColumnDefinition.default_val)
  return _impl_.default_val_.Release();
}
inline void ColumnDefinition::set_allocated_default_val(std::string* default_val) {
  if (default_val != nullptr) {
    
  } else {
    
  }
  _impl_.default_val_.SetAllocated(default_val, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default_val_.IsDefault()) {
    _impl_.default_val_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.ColumnDefinition.default_val)
}

// -------------------------------------------------------------------

// Index

// repeated string index_column = 1 [json_name = "indexColumn"];
inline int Index::_internal_index_column_size() const {
  return _impl_.index_column_.size();
}
inline int Index::index_column_size() const {
  return _internal_index_column_size();
}
inline void Index::clear_index_column() {
  _impl_.index_column_.Clear();
}
inline std::string* Index::add_index_column() {
  std::string* _s = _internal_add_index_column();
  // @@protoc_insertion_point(field_add_mutable:dingodb.pb.meta.Index.index_column)
  return _s;
}
inline const std::string& Index::_internal_index_column(int index) const {
  return _impl_.index_column_.Get(index);
}
inline const std::string& Index::index_column(int index) const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.Index.index_column)
  return _internal_index_column(index);
}
inline std::string* Index::mutable_index_column(int index) {
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.Index.index_column)
  return _impl_.index_column_.Mutable(index);
}
inline void Index::set_index_column(int index, const std::string& value) {
  _impl_.index_column_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.Index.index_column)
}
inline void Index::set_index_column(int index, std::string&& value) {
  _impl_.index_column_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.Index.index_column)
}
inline void Index::set_index_column(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.index_column_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dingodb.pb.meta.Index.index_column)
}
inline void Index::set_index_column(int index, const char* value, size_t size) {
  _impl_.index_column_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dingodb.pb.meta.Index.index_column)
}
inline std::string* Index::_internal_add_index_column() {
  return _impl_.index_column_.Add();
}
inline void Index::add_index_column(const std::string& value) {
  _impl_.index_column_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dingodb.pb.meta.Index.index_column)
}
inline void Index::add_index_column(std::string&& value) {
  _impl_.index_column_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:dingodb.pb.meta.Index.index_column)
}
inline void Index::add_index_column(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.index_column_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dingodb.pb.meta.Index.index_column)
}
inline void Index::add_index_column(const char* value, size_t size) {
  _impl_.index_column_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dingodb.pb.meta.Index.index_column)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Index::index_column() const {
  // @@protoc_insertion_point(field_list:dingodb.pb.meta.Index.index_column)
  return _impl_.index_column_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Index::mutable_index_column() {
  // @@protoc_insertion_point(field_mutable_list:dingodb.pb.meta.Index.index_column)
  return &_impl_.index_column_;
}

// bool is_unique = 2 [json_name = "isUnique"];
inline void Index::clear_is_unique() {
  _impl_.is_unique_ = false;
}
inline bool Index::_internal_is_unique() const {
  return _impl_.is_unique_;
}
inline bool Index::is_unique() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.Index.is_unique)
  return _internal_is_unique();
}
inline void Index::_internal_set_is_unique(bool value) {
  
  _impl_.is_unique_ = value;
}
inline void Index::set_is_unique(bool value) {
  _internal_set_is_unique(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.Index.is_unique)
}

// -------------------------------------------------------------------

// RangePartition

// repeated .dingodb.pb.common.Range ranges = 1 [json_name = "ranges"];
inline int RangePartition::_internal_ranges_size() const {
  return _impl_.ranges_.size();
}
inline int RangePartition::ranges_size() const {
  return _internal_ranges_size();
}
inline ::dingodb::pb::common::Range* RangePartition::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.RangePartition.ranges)
  return _impl_.ranges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Range >*
RangePartition::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:dingodb.pb.meta.RangePartition.ranges)
  return &_impl_.ranges_;
}
inline const ::dingodb::pb::common::Range& RangePartition::_internal_ranges(int index) const {
  return _impl_.ranges_.Get(index);
}
inline const ::dingodb::pb::common::Range& RangePartition::ranges(int index) const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.RangePartition.ranges)
  return _internal_ranges(index);
}
inline ::dingodb::pb::common::Range* RangePartition::_internal_add_ranges() {
  return _impl_.ranges_.Add();
}
inline ::dingodb::pb::common::Range* RangePartition::add_ranges() {
  ::dingodb::pb::common::Range* _add = _internal_add_ranges();
  // @@protoc_insertion_point(field_add:dingodb.pb.meta.RangePartition.ranges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Range >&
RangePartition::ranges() const {
  // @@protoc_insertion_point(field_list:dingodb.pb.meta.RangePartition.ranges)
  return _impl_.ranges_;
}

// -------------------------------------------------------------------

// HashPartition

// -------------------------------------------------------------------

// PartitionRule

// repeated string columns = 1 [json_name = "columns"];
inline int PartitionRule::_internal_columns_size() const {
  return _impl_.columns_.size();
}
inline int PartitionRule::columns_size() const {
  return _internal_columns_size();
}
inline void PartitionRule::clear_columns() {
  _impl_.columns_.Clear();
}
inline std::string* PartitionRule::add_columns() {
  std::string* _s = _internal_add_columns();
  // @@protoc_insertion_point(field_add_mutable:dingodb.pb.meta.PartitionRule.columns)
  return _s;
}
inline const std::string& PartitionRule::_internal_columns(int index) const {
  return _impl_.columns_.Get(index);
}
inline const std::string& PartitionRule::columns(int index) const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.PartitionRule.columns)
  return _internal_columns(index);
}
inline std::string* PartitionRule::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.PartitionRule.columns)
  return _impl_.columns_.Mutable(index);
}
inline void PartitionRule::set_columns(int index, const std::string& value) {
  _impl_.columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.PartitionRule.columns)
}
inline void PartitionRule::set_columns(int index, std::string&& value) {
  _impl_.columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.PartitionRule.columns)
}
inline void PartitionRule::set_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dingodb.pb.meta.PartitionRule.columns)
}
inline void PartitionRule::set_columns(int index, const char* value, size_t size) {
  _impl_.columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dingodb.pb.meta.PartitionRule.columns)
}
inline std::string* PartitionRule::_internal_add_columns() {
  return _impl_.columns_.Add();
}
inline void PartitionRule::add_columns(const std::string& value) {
  _impl_.columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dingodb.pb.meta.PartitionRule.columns)
}
inline void PartitionRule::add_columns(std::string&& value) {
  _impl_.columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:dingodb.pb.meta.PartitionRule.columns)
}
inline void PartitionRule::add_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dingodb.pb.meta.PartitionRule.columns)
}
inline void PartitionRule::add_columns(const char* value, size_t size) {
  _impl_.columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dingodb.pb.meta.PartitionRule.columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PartitionRule::columns() const {
  // @@protoc_insertion_point(field_list:dingodb.pb.meta.PartitionRule.columns)
  return _impl_.columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PartitionRule::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:dingodb.pb.meta.PartitionRule.columns)
  return &_impl_.columns_;
}

// .dingodb.pb.meta.PartitionStrategy strategy = 2 [json_name = "strategy"];
inline void PartitionRule::clear_strategy() {
  _impl_.strategy_ = 0;
}
inline ::dingodb::pb::meta::PartitionStrategy PartitionRule::_internal_strategy() const {
  return static_cast< ::dingodb::pb::meta::PartitionStrategy >(_impl_.strategy_);
}
inline ::dingodb::pb::meta::PartitionStrategy PartitionRule::strategy() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.PartitionRule.strategy)
  return _internal_strategy();
}
inline void PartitionRule::_internal_set_strategy(::dingodb::pb::meta::PartitionStrategy value) {
  
  _impl_.strategy_ = value;
}
inline void PartitionRule::set_strategy(::dingodb::pb::meta::PartitionStrategy value) {
  _internal_set_strategy(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.PartitionRule.strategy)
}

// .dingodb.pb.meta.RangePartition range_partition = 3 [json_name = "rangePartition"];
inline bool PartitionRule::_internal_has_range_partition() const {
  return this != internal_default_instance() && _impl_.range_partition_ != nullptr;
}
inline bool PartitionRule::has_range_partition() const {
  return _internal_has_range_partition();
}
inline void PartitionRule::clear_range_partition() {
  if (GetArenaForAllocation() == nullptr && _impl_.range_partition_ != nullptr) {
    delete _impl_.range_partition_;
  }
  _impl_.range_partition_ = nullptr;
}
inline const ::dingodb::pb::meta::RangePartition& PartitionRule::_internal_range_partition() const {
  const ::dingodb::pb::meta::RangePartition* p = _impl_.range_partition_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::RangePartition&>(
      ::dingodb::pb::meta::_RangePartition_default_instance_);
}
inline const ::dingodb::pb::meta::RangePartition& PartitionRule::range_partition() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.PartitionRule.range_partition)
  return _internal_range_partition();
}
inline void PartitionRule::unsafe_arena_set_allocated_range_partition(
    ::dingodb::pb::meta::RangePartition* range_partition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.range_partition_);
  }
  _impl_.range_partition_ = range_partition;
  if (range_partition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.PartitionRule.range_partition)
}
inline ::dingodb::pb::meta::RangePartition* PartitionRule::release_range_partition() {
  
  ::dingodb::pb::meta::RangePartition* temp = _impl_.range_partition_;
  _impl_.range_partition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::RangePartition* PartitionRule::unsafe_arena_release_range_partition() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.PartitionRule.range_partition)
  
  ::dingodb::pb::meta::RangePartition* temp = _impl_.range_partition_;
  _impl_.range_partition_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::RangePartition* PartitionRule::_internal_mutable_range_partition() {
  
  if (_impl_.range_partition_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::RangePartition>(GetArenaForAllocation());
    _impl_.range_partition_ = p;
  }
  return _impl_.range_partition_;
}
inline ::dingodb::pb::meta::RangePartition* PartitionRule::mutable_range_partition() {
  ::dingodb::pb::meta::RangePartition* _msg = _internal_mutable_range_partition();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.PartitionRule.range_partition)
  return _msg;
}
inline void PartitionRule::set_allocated_range_partition(::dingodb::pb::meta::RangePartition* range_partition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.range_partition_;
  }
  if (range_partition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(range_partition);
    if (message_arena != submessage_arena) {
      range_partition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range_partition, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.range_partition_ = range_partition;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.PartitionRule.range_partition)
}

// .dingodb.pb.meta.HashPartition hash_partition = 4 [json_name = "hashPartition"];
inline bool PartitionRule::_internal_has_hash_partition() const {
  return this != internal_default_instance() && _impl_.hash_partition_ != nullptr;
}
inline bool PartitionRule::has_hash_partition() const {
  return _internal_has_hash_partition();
}
inline void PartitionRule::clear_hash_partition() {
  if (GetArenaForAllocation() == nullptr && _impl_.hash_partition_ != nullptr) {
    delete _impl_.hash_partition_;
  }
  _impl_.hash_partition_ = nullptr;
}
inline const ::dingodb::pb::meta::HashPartition& PartitionRule::_internal_hash_partition() const {
  const ::dingodb::pb::meta::HashPartition* p = _impl_.hash_partition_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::HashPartition&>(
      ::dingodb::pb::meta::_HashPartition_default_instance_);
}
inline const ::dingodb::pb::meta::HashPartition& PartitionRule::hash_partition() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.PartitionRule.hash_partition)
  return _internal_hash_partition();
}
inline void PartitionRule::unsafe_arena_set_allocated_hash_partition(
    ::dingodb::pb::meta::HashPartition* hash_partition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hash_partition_);
  }
  _impl_.hash_partition_ = hash_partition;
  if (hash_partition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.PartitionRule.hash_partition)
}
inline ::dingodb::pb::meta::HashPartition* PartitionRule::release_hash_partition() {
  
  ::dingodb::pb::meta::HashPartition* temp = _impl_.hash_partition_;
  _impl_.hash_partition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::HashPartition* PartitionRule::unsafe_arena_release_hash_partition() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.PartitionRule.hash_partition)
  
  ::dingodb::pb::meta::HashPartition* temp = _impl_.hash_partition_;
  _impl_.hash_partition_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::HashPartition* PartitionRule::_internal_mutable_hash_partition() {
  
  if (_impl_.hash_partition_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::HashPartition>(GetArenaForAllocation());
    _impl_.hash_partition_ = p;
  }
  return _impl_.hash_partition_;
}
inline ::dingodb::pb::meta::HashPartition* PartitionRule::mutable_hash_partition() {
  ::dingodb::pb::meta::HashPartition* _msg = _internal_mutable_hash_partition();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.PartitionRule.hash_partition)
  return _msg;
}
inline void PartitionRule::set_allocated_hash_partition(::dingodb::pb::meta::HashPartition* hash_partition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hash_partition_;
  }
  if (hash_partition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hash_partition);
    if (message_arena != submessage_arena) {
      hash_partition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hash_partition, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.hash_partition_ = hash_partition;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.PartitionRule.hash_partition)
}

// -------------------------------------------------------------------

// Schema

// .dingodb.pb.meta.DingoCommonId id = 1 [json_name = "id"];
inline bool Schema::_internal_has_id() const {
  return this != internal_default_instance() && _impl_.id_ != nullptr;
}
inline bool Schema::has_id() const {
  return _internal_has_id();
}
inline void Schema::clear_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.id_ != nullptr) {
    delete _impl_.id_;
  }
  _impl_.id_ = nullptr;
}
inline const ::dingodb::pb::meta::DingoCommonId& Schema::_internal_id() const {
  const ::dingodb::pb::meta::DingoCommonId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::DingoCommonId&>(
      ::dingodb::pb::meta::_DingoCommonId_default_instance_);
}
inline const ::dingodb::pb::meta::DingoCommonId& Schema::id() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.Schema.id)
  return _internal_id();
}
inline void Schema::unsafe_arena_set_allocated_id(
    ::dingodb::pb::meta::DingoCommonId* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.Schema.id)
}
inline ::dingodb::pb::meta::DingoCommonId* Schema::release_id() {
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* Schema::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.Schema.id)
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* Schema::_internal_mutable_id() {
  
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::DingoCommonId>(GetArenaForAllocation());
    _impl_.id_ = p;
  }
  return _impl_.id_;
}
inline ::dingodb::pb::meta::DingoCommonId* Schema::mutable_id() {
  ::dingodb::pb::meta::DingoCommonId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.Schema.id)
  return _msg;
}
inline void Schema::set_allocated_id(::dingodb::pb::meta::DingoCommonId* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.id_ = id;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.Schema.id)
}

// string name = 2 [json_name = "name"];
inline void Schema::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Schema::name() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.Schema.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schema::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.Schema.name)
}
inline std::string* Schema::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.Schema.name)
  return _s;
}
inline const std::string& Schema::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Schema::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Schema::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Schema::release_name() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.Schema.name)
  return _impl_.name_.Release();
}
inline void Schema::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.Schema.name)
}

// repeated .dingodb.pb.meta.DingoCommonId schema_ids = 3 [json_name = "schemaIds"];
inline int Schema::_internal_schema_ids_size() const {
  return _impl_.schema_ids_.size();
}
inline int Schema::schema_ids_size() const {
  return _internal_schema_ids_size();
}
inline void Schema::clear_schema_ids() {
  _impl_.schema_ids_.Clear();
}
inline ::dingodb::pb::meta::DingoCommonId* Schema::mutable_schema_ids(int index) {
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.Schema.schema_ids)
  return _impl_.schema_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::DingoCommonId >*
Schema::mutable_schema_ids() {
  // @@protoc_insertion_point(field_mutable_list:dingodb.pb.meta.Schema.schema_ids)
  return &_impl_.schema_ids_;
}
inline const ::dingodb::pb::meta::DingoCommonId& Schema::_internal_schema_ids(int index) const {
  return _impl_.schema_ids_.Get(index);
}
inline const ::dingodb::pb::meta::DingoCommonId& Schema::schema_ids(int index) const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.Schema.schema_ids)
  return _internal_schema_ids(index);
}
inline ::dingodb::pb::meta::DingoCommonId* Schema::_internal_add_schema_ids() {
  return _impl_.schema_ids_.Add();
}
inline ::dingodb::pb::meta::DingoCommonId* Schema::add_schema_ids() {
  ::dingodb::pb::meta::DingoCommonId* _add = _internal_add_schema_ids();
  // @@protoc_insertion_point(field_add:dingodb.pb.meta.Schema.schema_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::DingoCommonId >&
Schema::schema_ids() const {
  // @@protoc_insertion_point(field_list:dingodb.pb.meta.Schema.schema_ids)
  return _impl_.schema_ids_;
}

// repeated .dingodb.pb.meta.DingoCommonId table_ids = 4 [json_name = "tableIds"];
inline int Schema::_internal_table_ids_size() const {
  return _impl_.table_ids_.size();
}
inline int Schema::table_ids_size() const {
  return _internal_table_ids_size();
}
inline void Schema::clear_table_ids() {
  _impl_.table_ids_.Clear();
}
inline ::dingodb::pb::meta::DingoCommonId* Schema::mutable_table_ids(int index) {
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.Schema.table_ids)
  return _impl_.table_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::DingoCommonId >*
Schema::mutable_table_ids() {
  // @@protoc_insertion_point(field_mutable_list:dingodb.pb.meta.Schema.table_ids)
  return &_impl_.table_ids_;
}
inline const ::dingodb::pb::meta::DingoCommonId& Schema::_internal_table_ids(int index) const {
  return _impl_.table_ids_.Get(index);
}
inline const ::dingodb::pb::meta::DingoCommonId& Schema::table_ids(int index) const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.Schema.table_ids)
  return _internal_table_ids(index);
}
inline ::dingodb::pb::meta::DingoCommonId* Schema::_internal_add_table_ids() {
  return _impl_.table_ids_.Add();
}
inline ::dingodb::pb::meta::DingoCommonId* Schema::add_table_ids() {
  ::dingodb::pb::meta::DingoCommonId* _add = _internal_add_table_ids();
  // @@protoc_insertion_point(field_add:dingodb.pb.meta.Schema.table_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::DingoCommonId >&
Schema::table_ids() const {
  // @@protoc_insertion_point(field_list:dingodb.pb.meta.Schema.table_ids)
  return _impl_.table_ids_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TableDefinition

// string name = 1 [json_name = "name"];
inline void TableDefinition::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TableDefinition::name() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.TableDefinition.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableDefinition::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.TableDefinition.name)
}
inline std::string* TableDefinition::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.TableDefinition.name)
  return _s;
}
inline const std::string& TableDefinition::_internal_name() const {
  return _impl_.name_.Get();
}
inline void TableDefinition::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TableDefinition::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* TableDefinition::release_name() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.TableDefinition.name)
  return _impl_.name_.Release();
}
inline void TableDefinition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.TableDefinition.name)
}

// repeated .dingodb.pb.meta.ColumnDefinition columns = 2 [json_name = "columns"];
inline int TableDefinition::_internal_columns_size() const {
  return _impl_.columns_.size();
}
inline int TableDefinition::columns_size() const {
  return _internal_columns_size();
}
inline void TableDefinition::clear_columns() {
  _impl_.columns_.Clear();
}
inline ::dingodb::pb::meta::ColumnDefinition* TableDefinition::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.TableDefinition.columns)
  return _impl_.columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::ColumnDefinition >*
TableDefinition::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:dingodb.pb.meta.TableDefinition.columns)
  return &_impl_.columns_;
}
inline const ::dingodb::pb::meta::ColumnDefinition& TableDefinition::_internal_columns(int index) const {
  return _impl_.columns_.Get(index);
}
inline const ::dingodb::pb::meta::ColumnDefinition& TableDefinition::columns(int index) const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.TableDefinition.columns)
  return _internal_columns(index);
}
inline ::dingodb::pb::meta::ColumnDefinition* TableDefinition::_internal_add_columns() {
  return _impl_.columns_.Add();
}
inline ::dingodb::pb::meta::ColumnDefinition* TableDefinition::add_columns() {
  ::dingodb::pb::meta::ColumnDefinition* _add = _internal_add_columns();
  // @@protoc_insertion_point(field_add:dingodb.pb.meta.TableDefinition.columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::ColumnDefinition >&
TableDefinition::columns() const {
  // @@protoc_insertion_point(field_list:dingodb.pb.meta.TableDefinition.columns)
  return _impl_.columns_;
}

// map<string, .dingodb.pb.meta.Index> indexes = 3 [json_name = "indexes"];
inline int TableDefinition::_internal_indexes_size() const {
  return _impl_.indexes_.size();
}
inline int TableDefinition::indexes_size() const {
  return _internal_indexes_size();
}
inline void TableDefinition::clear_indexes() {
  _impl_.indexes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::dingodb::pb::meta::Index >&
TableDefinition::_internal_indexes() const {
  return _impl_.indexes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::dingodb::pb::meta::Index >&
TableDefinition::indexes() const {
  // @@protoc_insertion_point(field_map:dingodb.pb.meta.TableDefinition.indexes)
  return _internal_indexes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::dingodb::pb::meta::Index >*
TableDefinition::_internal_mutable_indexes() {
  return _impl_.indexes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::dingodb::pb::meta::Index >*
TableDefinition::mutable_indexes() {
  // @@protoc_insertion_point(field_mutable_map:dingodb.pb.meta.TableDefinition.indexes)
  return _internal_mutable_indexes();
}

// uint32 version = 4 [json_name = "version"];
inline void TableDefinition::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t TableDefinition::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t TableDefinition::version() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.TableDefinition.version)
  return _internal_version();
}
inline void TableDefinition::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void TableDefinition::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.TableDefinition.version)
}

// uint64 ttl = 5 [json_name = "ttl"];
inline void TableDefinition::clear_ttl() {
  _impl_.ttl_ = uint64_t{0u};
}
inline uint64_t TableDefinition::_internal_ttl() const {
  return _impl_.ttl_;
}
inline uint64_t TableDefinition::ttl() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.TableDefinition.ttl)
  return _internal_ttl();
}
inline void TableDefinition::_internal_set_ttl(uint64_t value) {
  
  _impl_.ttl_ = value;
}
inline void TableDefinition::set_ttl(uint64_t value) {
  _internal_set_ttl(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.TableDefinition.ttl)
}

// .dingodb.pb.meta.PartitionRule table_partition = 6 [json_name = "tablePartition"];
inline bool TableDefinition::_internal_has_table_partition() const {
  return this != internal_default_instance() && _impl_.table_partition_ != nullptr;
}
inline bool TableDefinition::has_table_partition() const {
  return _internal_has_table_partition();
}
inline void TableDefinition::clear_table_partition() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_partition_ != nullptr) {
    delete _impl_.table_partition_;
  }
  _impl_.table_partition_ = nullptr;
}
inline const ::dingodb::pb::meta::PartitionRule& TableDefinition::_internal_table_partition() const {
  const ::dingodb::pb::meta::PartitionRule* p = _impl_.table_partition_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::PartitionRule&>(
      ::dingodb::pb::meta::_PartitionRule_default_instance_);
}
inline const ::dingodb::pb::meta::PartitionRule& TableDefinition::table_partition() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.TableDefinition.table_partition)
  return _internal_table_partition();
}
inline void TableDefinition::unsafe_arena_set_allocated_table_partition(
    ::dingodb::pb::meta::PartitionRule* table_partition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_partition_);
  }
  _impl_.table_partition_ = table_partition;
  if (table_partition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.TableDefinition.table_partition)
}
inline ::dingodb::pb::meta::PartitionRule* TableDefinition::release_table_partition() {
  
  ::dingodb::pb::meta::PartitionRule* temp = _impl_.table_partition_;
  _impl_.table_partition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::PartitionRule* TableDefinition::unsafe_arena_release_table_partition() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.TableDefinition.table_partition)
  
  ::dingodb::pb::meta::PartitionRule* temp = _impl_.table_partition_;
  _impl_.table_partition_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::PartitionRule* TableDefinition::_internal_mutable_table_partition() {
  
  if (_impl_.table_partition_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::PartitionRule>(GetArenaForAllocation());
    _impl_.table_partition_ = p;
  }
  return _impl_.table_partition_;
}
inline ::dingodb::pb::meta::PartitionRule* TableDefinition::mutable_table_partition() {
  ::dingodb::pb::meta::PartitionRule* _msg = _internal_mutable_table_partition();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.TableDefinition.table_partition)
  return _msg;
}
inline void TableDefinition::set_allocated_table_partition(::dingodb::pb::meta::PartitionRule* table_partition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_partition_;
  }
  if (table_partition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_partition);
    if (message_arena != submessage_arena) {
      table_partition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_partition, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_partition_ = table_partition;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.TableDefinition.table_partition)
}

// .dingodb.pb.common.Engine engine = 7 [json_name = "engine"];
inline void TableDefinition::clear_engine() {
  _impl_.engine_ = 0;
}
inline ::dingodb::pb::common::Engine TableDefinition::_internal_engine() const {
  return static_cast< ::dingodb::pb::common::Engine >(_impl_.engine_);
}
inline ::dingodb::pb::common::Engine TableDefinition::engine() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.TableDefinition.engine)
  return _internal_engine();
}
inline void TableDefinition::_internal_set_engine(::dingodb::pb::common::Engine value) {
  
  _impl_.engine_ = value;
}
inline void TableDefinition::set_engine(::dingodb::pb::common::Engine value) {
  _internal_set_engine(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.TableDefinition.engine)
}

// map<string, string> properties = 8 [json_name = "properties"];
inline int TableDefinition::_internal_properties_size() const {
  return _impl_.properties_.size();
}
inline int TableDefinition::properties_size() const {
  return _internal_properties_size();
}
inline void TableDefinition::clear_properties() {
  _impl_.properties_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TableDefinition::_internal_properties() const {
  return _impl_.properties_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TableDefinition::properties() const {
  // @@protoc_insertion_point(field_map:dingodb.pb.meta.TableDefinition.properties)
  return _internal_properties();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TableDefinition::_internal_mutable_properties() {
  return _impl_.properties_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TableDefinition::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_map:dingodb.pb.meta.TableDefinition.properties)
  return _internal_mutable_properties();
}

// -------------------------------------------------------------------

// Part

// .dingodb.pb.meta.DingoCommonId id = 1 [json_name = "id"];
inline bool Part::_internal_has_id() const {
  return this != internal_default_instance() && _impl_.id_ != nullptr;
}
inline bool Part::has_id() const {
  return _internal_has_id();
}
inline void Part::clear_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.id_ != nullptr) {
    delete _impl_.id_;
  }
  _impl_.id_ = nullptr;
}
inline const ::dingodb::pb::meta::DingoCommonId& Part::_internal_id() const {
  const ::dingodb::pb::meta::DingoCommonId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::DingoCommonId&>(
      ::dingodb::pb::meta::_DingoCommonId_default_instance_);
}
inline const ::dingodb::pb::meta::DingoCommonId& Part::id() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.Part.id)
  return _internal_id();
}
inline void Part::unsafe_arena_set_allocated_id(
    ::dingodb::pb::meta::DingoCommonId* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.Part.id)
}
inline ::dingodb::pb::meta::DingoCommonId* Part::release_id() {
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* Part::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.Part.id)
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* Part::_internal_mutable_id() {
  
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::DingoCommonId>(GetArenaForAllocation());
    _impl_.id_ = p;
  }
  return _impl_.id_;
}
inline ::dingodb::pb::meta::DingoCommonId* Part::mutable_id() {
  ::dingodb::pb::meta::DingoCommonId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.Part.id)
  return _msg;
}
inline void Part::set_allocated_id(::dingodb::pb::meta::DingoCommonId* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.id_ = id;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.Part.id)
}

// .dingodb.pb.common.Range range = 2 [json_name = "range"];
inline bool Part::_internal_has_range() const {
  return this != internal_default_instance() && _impl_.range_ != nullptr;
}
inline bool Part::has_range() const {
  return _internal_has_range();
}
inline const ::dingodb::pb::common::Range& Part::_internal_range() const {
  const ::dingodb::pb::common::Range* p = _impl_.range_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::common::Range&>(
      ::dingodb::pb::common::_Range_default_instance_);
}
inline const ::dingodb::pb::common::Range& Part::range() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.Part.range)
  return _internal_range();
}
inline void Part::unsafe_arena_set_allocated_range(
    ::dingodb::pb::common::Range* range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.range_);
  }
  _impl_.range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.Part.range)
}
inline ::dingodb::pb::common::Range* Part::release_range() {
  
  ::dingodb::pb::common::Range* temp = _impl_.range_;
  _impl_.range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::common::Range* Part::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.Part.range)
  
  ::dingodb::pb::common::Range* temp = _impl_.range_;
  _impl_.range_ = nullptr;
  return temp;
}
inline ::dingodb::pb::common::Range* Part::_internal_mutable_range() {
  
  if (_impl_.range_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::common::Range>(GetArenaForAllocation());
    _impl_.range_ = p;
  }
  return _impl_.range_;
}
inline ::dingodb::pb::common::Range* Part::mutable_range() {
  ::dingodb::pb::common::Range* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.Part.range)
  return _msg;
}
inline void Part::set_allocated_range(::dingodb::pb::common::Range* range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.range_);
  }
  if (range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(range));
    if (message_arena != submessage_arena) {
      range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.range_ = range;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.Part.range)
}

// .dingodb.pb.common.Location leader = 3 [json_name = "leader"];
inline bool Part::_internal_has_leader() const {
  return this != internal_default_instance() && _impl_.leader_ != nullptr;
}
inline bool Part::has_leader() const {
  return _internal_has_leader();
}
inline const ::dingodb::pb::common::Location& Part::_internal_leader() const {
  const ::dingodb::pb::common::Location* p = _impl_.leader_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::common::Location&>(
      ::dingodb::pb::common::_Location_default_instance_);
}
inline const ::dingodb::pb::common::Location& Part::leader() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.Part.leader)
  return _internal_leader();
}
inline void Part::unsafe_arena_set_allocated_leader(
    ::dingodb::pb::common::Location* leader) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leader_);
  }
  _impl_.leader_ = leader;
  if (leader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.Part.leader)
}
inline ::dingodb::pb::common::Location* Part::release_leader() {
  
  ::dingodb::pb::common::Location* temp = _impl_.leader_;
  _impl_.leader_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::common::Location* Part::unsafe_arena_release_leader() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.Part.leader)
  
  ::dingodb::pb::common::Location* temp = _impl_.leader_;
  _impl_.leader_ = nullptr;
  return temp;
}
inline ::dingodb::pb::common::Location* Part::_internal_mutable_leader() {
  
  if (_impl_.leader_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::common::Location>(GetArenaForAllocation());
    _impl_.leader_ = p;
  }
  return _impl_.leader_;
}
inline ::dingodb::pb::common::Location* Part::mutable_leader() {
  ::dingodb::pb::common::Location* _msg = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.Part.leader)
  return _msg;
}
inline void Part::set_allocated_leader(::dingodb::pb::common::Location* leader) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.leader_);
  }
  if (leader) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(leader));
    if (message_arena != submessage_arena) {
      leader = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leader, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.leader_ = leader;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.Part.leader)
}

// repeated .dingodb.pb.common.Location voters = 4 [json_name = "voters"];
inline int Part::_internal_voters_size() const {
  return _impl_.voters_.size();
}
inline int Part::voters_size() const {
  return _internal_voters_size();
}
inline ::dingodb::pb::common::Location* Part::mutable_voters(int index) {
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.Part.voters)
  return _impl_.voters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Location >*
Part::mutable_voters() {
  // @@protoc_insertion_point(field_mutable_list:dingodb.pb.meta.Part.voters)
  return &_impl_.voters_;
}
inline const ::dingodb::pb::common::Location& Part::_internal_voters(int index) const {
  return _impl_.voters_.Get(index);
}
inline const ::dingodb::pb::common::Location& Part::voters(int index) const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.Part.voters)
  return _internal_voters(index);
}
inline ::dingodb::pb::common::Location* Part::_internal_add_voters() {
  return _impl_.voters_.Add();
}
inline ::dingodb::pb::common::Location* Part::add_voters() {
  ::dingodb::pb::common::Location* _add = _internal_add_voters();
  // @@protoc_insertion_point(field_add:dingodb.pb.meta.Part.voters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Location >&
Part::voters() const {
  // @@protoc_insertion_point(field_list:dingodb.pb.meta.Part.voters)
  return _impl_.voters_;
}

// repeated .dingodb.pb.common.Location learners = 5 [json_name = "learners"];
inline int Part::_internal_learners_size() const {
  return _impl_.learners_.size();
}
inline int Part::learners_size() const {
  return _internal_learners_size();
}
inline ::dingodb::pb::common::Location* Part::mutable_learners(int index) {
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.Part.learners)
  return _impl_.learners_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Location >*
Part::mutable_learners() {
  // @@protoc_insertion_point(field_mutable_list:dingodb.pb.meta.Part.learners)
  return &_impl_.learners_;
}
inline const ::dingodb::pb::common::Location& Part::_internal_learners(int index) const {
  return _impl_.learners_.Get(index);
}
inline const ::dingodb::pb::common::Location& Part::learners(int index) const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.Part.learners)
  return _internal_learners(index);
}
inline ::dingodb::pb::common::Location* Part::_internal_add_learners() {
  return _impl_.learners_.Add();
}
inline ::dingodb::pb::common::Location* Part::add_learners() {
  ::dingodb::pb::common::Location* _add = _internal_add_learners();
  // @@protoc_insertion_point(field_add:dingodb.pb.meta.Part.learners)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Location >&
Part::learners() const {
  // @@protoc_insertion_point(field_list:dingodb.pb.meta.Part.learners)
  return _impl_.learners_;
}

// uint64 regionmap_epoch = 6 [json_name = "regionmapEpoch"];
inline void Part::clear_regionmap_epoch() {
  _impl_.regionmap_epoch_ = uint64_t{0u};
}
inline uint64_t Part::_internal_regionmap_epoch() const {
  return _impl_.regionmap_epoch_;
}
inline uint64_t Part::regionmap_epoch() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.Part.regionmap_epoch)
  return _internal_regionmap_epoch();
}
inline void Part::_internal_set_regionmap_epoch(uint64_t value) {
  
  _impl_.regionmap_epoch_ = value;
}
inline void Part::set_regionmap_epoch(uint64_t value) {
  _internal_set_regionmap_epoch(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.Part.regionmap_epoch)
}

// uint64 storemap_epoch = 7 [json_name = "storemapEpoch"];
inline void Part::clear_storemap_epoch() {
  _impl_.storemap_epoch_ = uint64_t{0u};
}
inline uint64_t Part::_internal_storemap_epoch() const {
  return _impl_.storemap_epoch_;
}
inline uint64_t Part::storemap_epoch() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.Part.storemap_epoch)
  return _internal_storemap_epoch();
}
inline void Part::_internal_set_storemap_epoch(uint64_t value) {
  
  _impl_.storemap_epoch_ = value;
}
inline void Part::set_storemap_epoch(uint64_t value) {
  _internal_set_storemap_epoch(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.Part.storemap_epoch)
}

// -------------------------------------------------------------------

// Table

// .dingodb.pb.meta.DingoCommonId id = 1 [json_name = "id"];
inline bool Table::_internal_has_id() const {
  return this != internal_default_instance() && _impl_.id_ != nullptr;
}
inline bool Table::has_id() const {
  return _internal_has_id();
}
inline void Table::clear_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.id_ != nullptr) {
    delete _impl_.id_;
  }
  _impl_.id_ = nullptr;
}
inline const ::dingodb::pb::meta::DingoCommonId& Table::_internal_id() const {
  const ::dingodb::pb::meta::DingoCommonId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::DingoCommonId&>(
      ::dingodb::pb::meta::_DingoCommonId_default_instance_);
}
inline const ::dingodb::pb::meta::DingoCommonId& Table::id() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.Table.id)
  return _internal_id();
}
inline void Table::unsafe_arena_set_allocated_id(
    ::dingodb::pb::meta::DingoCommonId* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.Table.id)
}
inline ::dingodb::pb::meta::DingoCommonId* Table::release_id() {
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* Table::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.Table.id)
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* Table::_internal_mutable_id() {
  
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::DingoCommonId>(GetArenaForAllocation());
    _impl_.id_ = p;
  }
  return _impl_.id_;
}
inline ::dingodb::pb::meta::DingoCommonId* Table::mutable_id() {
  ::dingodb::pb::meta::DingoCommonId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.Table.id)
  return _msg;
}
inline void Table::set_allocated_id(::dingodb::pb::meta::DingoCommonId* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.id_ = id;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.Table.id)
}

// repeated .dingodb.pb.meta.Part parts = 2 [json_name = "parts"];
inline int Table::_internal_parts_size() const {
  return _impl_.parts_.size();
}
inline int Table::parts_size() const {
  return _internal_parts_size();
}
inline void Table::clear_parts() {
  _impl_.parts_.Clear();
}
inline ::dingodb::pb::meta::Part* Table::mutable_parts(int index) {
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.Table.parts)
  return _impl_.parts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::Part >*
Table::mutable_parts() {
  // @@protoc_insertion_point(field_mutable_list:dingodb.pb.meta.Table.parts)
  return &_impl_.parts_;
}
inline const ::dingodb::pb::meta::Part& Table::_internal_parts(int index) const {
  return _impl_.parts_.Get(index);
}
inline const ::dingodb::pb::meta::Part& Table::parts(int index) const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.Table.parts)
  return _internal_parts(index);
}
inline ::dingodb::pb::meta::Part* Table::_internal_add_parts() {
  return _impl_.parts_.Add();
}
inline ::dingodb::pb::meta::Part* Table::add_parts() {
  ::dingodb::pb::meta::Part* _add = _internal_add_parts();
  // @@protoc_insertion_point(field_add:dingodb.pb.meta.Table.parts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::Part >&
Table::parts() const {
  // @@protoc_insertion_point(field_list:dingodb.pb.meta.Table.parts)
  return _impl_.parts_;
}

// -------------------------------------------------------------------

// GetSchemasRequest

// .dingodb.pb.meta.DingoCommonId schema_id = 1 [json_name = "schemaId"];
inline bool GetSchemasRequest::_internal_has_schema_id() const {
  return this != internal_default_instance() && _impl_.schema_id_ != nullptr;
}
inline bool GetSchemasRequest::has_schema_id() const {
  return _internal_has_schema_id();
}
inline void GetSchemasRequest::clear_schema_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.schema_id_ != nullptr) {
    delete _impl_.schema_id_;
  }
  _impl_.schema_id_ = nullptr;
}
inline const ::dingodb::pb::meta::DingoCommonId& GetSchemasRequest::_internal_schema_id() const {
  const ::dingodb::pb::meta::DingoCommonId* p = _impl_.schema_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::DingoCommonId&>(
      ::dingodb::pb::meta::_DingoCommonId_default_instance_);
}
inline const ::dingodb::pb::meta::DingoCommonId& GetSchemasRequest::schema_id() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.GetSchemasRequest.schema_id)
  return _internal_schema_id();
}
inline void GetSchemasRequest::unsafe_arena_set_allocated_schema_id(
    ::dingodb::pb::meta::DingoCommonId* schema_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_id_);
  }
  _impl_.schema_id_ = schema_id;
  if (schema_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.GetSchemasRequest.schema_id)
}
inline ::dingodb::pb::meta::DingoCommonId* GetSchemasRequest::release_schema_id() {
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.schema_id_;
  _impl_.schema_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* GetSchemasRequest::unsafe_arena_release_schema_id() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.GetSchemasRequest.schema_id)
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.schema_id_;
  _impl_.schema_id_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* GetSchemasRequest::_internal_mutable_schema_id() {
  
  if (_impl_.schema_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::DingoCommonId>(GetArenaForAllocation());
    _impl_.schema_id_ = p;
  }
  return _impl_.schema_id_;
}
inline ::dingodb::pb::meta::DingoCommonId* GetSchemasRequest::mutable_schema_id() {
  ::dingodb::pb::meta::DingoCommonId* _msg = _internal_mutable_schema_id();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.GetSchemasRequest.schema_id)
  return _msg;
}
inline void GetSchemasRequest::set_allocated_schema_id(::dingodb::pb::meta::DingoCommonId* schema_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schema_id_;
  }
  if (schema_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schema_id);
    if (message_arena != submessage_arena) {
      schema_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.schema_id_ = schema_id;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.GetSchemasRequest.schema_id)
}

// -------------------------------------------------------------------

// GetSchemasResponse

// .dingodb.pb.error.Error error = 1 [json_name = "error"];
inline bool GetSchemasResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool GetSchemasResponse::has_error() const {
  return _internal_has_error();
}
inline const ::dingodb::pb::error::Error& GetSchemasResponse::_internal_error() const {
  const ::dingodb::pb::error::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::error::Error&>(
      ::dingodb::pb::error::_Error_default_instance_);
}
inline const ::dingodb::pb::error::Error& GetSchemasResponse::error() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.GetSchemasResponse.error)
  return _internal_error();
}
inline void GetSchemasResponse::unsafe_arena_set_allocated_error(
    ::dingodb::pb::error::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.GetSchemasResponse.error)
}
inline ::dingodb::pb::error::Error* GetSchemasResponse::release_error() {
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::error::Error* GetSchemasResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.GetSchemasResponse.error)
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::dingodb::pb::error::Error* GetSchemasResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::error::Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::dingodb::pb::error::Error* GetSchemasResponse::mutable_error() {
  ::dingodb::pb::error::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.GetSchemasResponse.error)
  return _msg;
}
inline void GetSchemasResponse::set_allocated_error(::dingodb::pb::error::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.GetSchemasResponse.error)
}

// repeated .dingodb.pb.meta.Schema schemas = 2 [json_name = "schemas"];
inline int GetSchemasResponse::_internal_schemas_size() const {
  return _impl_.schemas_.size();
}
inline int GetSchemasResponse::schemas_size() const {
  return _internal_schemas_size();
}
inline void GetSchemasResponse::clear_schemas() {
  _impl_.schemas_.Clear();
}
inline ::dingodb::pb::meta::Schema* GetSchemasResponse::mutable_schemas(int index) {
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.GetSchemasResponse.schemas)
  return _impl_.schemas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::Schema >*
GetSchemasResponse::mutable_schemas() {
  // @@protoc_insertion_point(field_mutable_list:dingodb.pb.meta.GetSchemasResponse.schemas)
  return &_impl_.schemas_;
}
inline const ::dingodb::pb::meta::Schema& GetSchemasResponse::_internal_schemas(int index) const {
  return _impl_.schemas_.Get(index);
}
inline const ::dingodb::pb::meta::Schema& GetSchemasResponse::schemas(int index) const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.GetSchemasResponse.schemas)
  return _internal_schemas(index);
}
inline ::dingodb::pb::meta::Schema* GetSchemasResponse::_internal_add_schemas() {
  return _impl_.schemas_.Add();
}
inline ::dingodb::pb::meta::Schema* GetSchemasResponse::add_schemas() {
  ::dingodb::pb::meta::Schema* _add = _internal_add_schemas();
  // @@protoc_insertion_point(field_add:dingodb.pb.meta.GetSchemasResponse.schemas)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::Schema >&
GetSchemasResponse::schemas() const {
  // @@protoc_insertion_point(field_list:dingodb.pb.meta.GetSchemasResponse.schemas)
  return _impl_.schemas_;
}

// -------------------------------------------------------------------

// TableDefinitionWithId

// .dingodb.pb.meta.DingoCommonId table_id = 1 [json_name = "tableId"];
inline bool TableDefinitionWithId::_internal_has_table_id() const {
  return this != internal_default_instance() && _impl_.table_id_ != nullptr;
}
inline bool TableDefinitionWithId::has_table_id() const {
  return _internal_has_table_id();
}
inline void TableDefinitionWithId::clear_table_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_id_ != nullptr) {
    delete _impl_.table_id_;
  }
  _impl_.table_id_ = nullptr;
}
inline const ::dingodb::pb::meta::DingoCommonId& TableDefinitionWithId::_internal_table_id() const {
  const ::dingodb::pb::meta::DingoCommonId* p = _impl_.table_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::DingoCommonId&>(
      ::dingodb::pb::meta::_DingoCommonId_default_instance_);
}
inline const ::dingodb::pb::meta::DingoCommonId& TableDefinitionWithId::table_id() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.TableDefinitionWithId.table_id)
  return _internal_table_id();
}
inline void TableDefinitionWithId::unsafe_arena_set_allocated_table_id(
    ::dingodb::pb::meta::DingoCommonId* table_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_id_);
  }
  _impl_.table_id_ = table_id;
  if (table_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.TableDefinitionWithId.table_id)
}
inline ::dingodb::pb::meta::DingoCommonId* TableDefinitionWithId::release_table_id() {
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* TableDefinitionWithId::unsafe_arena_release_table_id() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.TableDefinitionWithId.table_id)
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* TableDefinitionWithId::_internal_mutable_table_id() {
  
  if (_impl_.table_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::DingoCommonId>(GetArenaForAllocation());
    _impl_.table_id_ = p;
  }
  return _impl_.table_id_;
}
inline ::dingodb::pb::meta::DingoCommonId* TableDefinitionWithId::mutable_table_id() {
  ::dingodb::pb::meta::DingoCommonId* _msg = _internal_mutable_table_id();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.TableDefinitionWithId.table_id)
  return _msg;
}
inline void TableDefinitionWithId::set_allocated_table_id(::dingodb::pb::meta::DingoCommonId* table_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_id_;
  }
  if (table_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_id);
    if (message_arena != submessage_arena) {
      table_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_id_ = table_id;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.TableDefinitionWithId.table_id)
}

// .dingodb.pb.meta.TableDefinition table_definition = 2 [json_name = "tableDefinition"];
inline bool TableDefinitionWithId::_internal_has_table_definition() const {
  return this != internal_default_instance() && _impl_.table_definition_ != nullptr;
}
inline bool TableDefinitionWithId::has_table_definition() const {
  return _internal_has_table_definition();
}
inline void TableDefinitionWithId::clear_table_definition() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_definition_ != nullptr) {
    delete _impl_.table_definition_;
  }
  _impl_.table_definition_ = nullptr;
}
inline const ::dingodb::pb::meta::TableDefinition& TableDefinitionWithId::_internal_table_definition() const {
  const ::dingodb::pb::meta::TableDefinition* p = _impl_.table_definition_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::TableDefinition&>(
      ::dingodb::pb::meta::_TableDefinition_default_instance_);
}
inline const ::dingodb::pb::meta::TableDefinition& TableDefinitionWithId::table_definition() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.TableDefinitionWithId.table_definition)
  return _internal_table_definition();
}
inline void TableDefinitionWithId::unsafe_arena_set_allocated_table_definition(
    ::dingodb::pb::meta::TableDefinition* table_definition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_definition_);
  }
  _impl_.table_definition_ = table_definition;
  if (table_definition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.TableDefinitionWithId.table_definition)
}
inline ::dingodb::pb::meta::TableDefinition* TableDefinitionWithId::release_table_definition() {
  
  ::dingodb::pb::meta::TableDefinition* temp = _impl_.table_definition_;
  _impl_.table_definition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::TableDefinition* TableDefinitionWithId::unsafe_arena_release_table_definition() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.TableDefinitionWithId.table_definition)
  
  ::dingodb::pb::meta::TableDefinition* temp = _impl_.table_definition_;
  _impl_.table_definition_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::TableDefinition* TableDefinitionWithId::_internal_mutable_table_definition() {
  
  if (_impl_.table_definition_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::TableDefinition>(GetArenaForAllocation());
    _impl_.table_definition_ = p;
  }
  return _impl_.table_definition_;
}
inline ::dingodb::pb::meta::TableDefinition* TableDefinitionWithId::mutable_table_definition() {
  ::dingodb::pb::meta::TableDefinition* _msg = _internal_mutable_table_definition();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.TableDefinitionWithId.table_definition)
  return _msg;
}
inline void TableDefinitionWithId::set_allocated_table_definition(::dingodb::pb::meta::TableDefinition* table_definition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_definition_;
  }
  if (table_definition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_definition);
    if (message_arena != submessage_arena) {
      table_definition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_definition, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_definition_ = table_definition;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.TableDefinitionWithId.table_definition)
}

// -------------------------------------------------------------------

// GetTablesRequest

// .dingodb.pb.meta.DingoCommonId schema_id = 1 [json_name = "schemaId"];
inline bool GetTablesRequest::_internal_has_schema_id() const {
  return this != internal_default_instance() && _impl_.schema_id_ != nullptr;
}
inline bool GetTablesRequest::has_schema_id() const {
  return _internal_has_schema_id();
}
inline void GetTablesRequest::clear_schema_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.schema_id_ != nullptr) {
    delete _impl_.schema_id_;
  }
  _impl_.schema_id_ = nullptr;
}
inline const ::dingodb::pb::meta::DingoCommonId& GetTablesRequest::_internal_schema_id() const {
  const ::dingodb::pb::meta::DingoCommonId* p = _impl_.schema_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::DingoCommonId&>(
      ::dingodb::pb::meta::_DingoCommonId_default_instance_);
}
inline const ::dingodb::pb::meta::DingoCommonId& GetTablesRequest::schema_id() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.GetTablesRequest.schema_id)
  return _internal_schema_id();
}
inline void GetTablesRequest::unsafe_arena_set_allocated_schema_id(
    ::dingodb::pb::meta::DingoCommonId* schema_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_id_);
  }
  _impl_.schema_id_ = schema_id;
  if (schema_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.GetTablesRequest.schema_id)
}
inline ::dingodb::pb::meta::DingoCommonId* GetTablesRequest::release_schema_id() {
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.schema_id_;
  _impl_.schema_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* GetTablesRequest::unsafe_arena_release_schema_id() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.GetTablesRequest.schema_id)
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.schema_id_;
  _impl_.schema_id_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* GetTablesRequest::_internal_mutable_schema_id() {
  
  if (_impl_.schema_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::DingoCommonId>(GetArenaForAllocation());
    _impl_.schema_id_ = p;
  }
  return _impl_.schema_id_;
}
inline ::dingodb::pb::meta::DingoCommonId* GetTablesRequest::mutable_schema_id() {
  ::dingodb::pb::meta::DingoCommonId* _msg = _internal_mutable_schema_id();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.GetTablesRequest.schema_id)
  return _msg;
}
inline void GetTablesRequest::set_allocated_schema_id(::dingodb::pb::meta::DingoCommonId* schema_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schema_id_;
  }
  if (schema_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schema_id);
    if (message_arena != submessage_arena) {
      schema_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.schema_id_ = schema_id;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.GetTablesRequest.schema_id)
}

// -------------------------------------------------------------------

// GetTablesResponse

// .dingodb.pb.error.Error error = 1 [json_name = "error"];
inline bool GetTablesResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool GetTablesResponse::has_error() const {
  return _internal_has_error();
}
inline const ::dingodb::pb::error::Error& GetTablesResponse::_internal_error() const {
  const ::dingodb::pb::error::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::error::Error&>(
      ::dingodb::pb::error::_Error_default_instance_);
}
inline const ::dingodb::pb::error::Error& GetTablesResponse::error() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.GetTablesResponse.error)
  return _internal_error();
}
inline void GetTablesResponse::unsafe_arena_set_allocated_error(
    ::dingodb::pb::error::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.GetTablesResponse.error)
}
inline ::dingodb::pb::error::Error* GetTablesResponse::release_error() {
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::error::Error* GetTablesResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.GetTablesResponse.error)
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::dingodb::pb::error::Error* GetTablesResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::error::Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::dingodb::pb::error::Error* GetTablesResponse::mutable_error() {
  ::dingodb::pb::error::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.GetTablesResponse.error)
  return _msg;
}
inline void GetTablesResponse::set_allocated_error(::dingodb::pb::error::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.GetTablesResponse.error)
}

// repeated .dingodb.pb.meta.TableDefinitionWithId table_definition_with_ids = 2 [json_name = "tableDefinitionWithIds"];
inline int GetTablesResponse::_internal_table_definition_with_ids_size() const {
  return _impl_.table_definition_with_ids_.size();
}
inline int GetTablesResponse::table_definition_with_ids_size() const {
  return _internal_table_definition_with_ids_size();
}
inline void GetTablesResponse::clear_table_definition_with_ids() {
  _impl_.table_definition_with_ids_.Clear();
}
inline ::dingodb::pb::meta::TableDefinitionWithId* GetTablesResponse::mutable_table_definition_with_ids(int index) {
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.GetTablesResponse.table_definition_with_ids)
  return _impl_.table_definition_with_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::TableDefinitionWithId >*
GetTablesResponse::mutable_table_definition_with_ids() {
  // @@protoc_insertion_point(field_mutable_list:dingodb.pb.meta.GetTablesResponse.table_definition_with_ids)
  return &_impl_.table_definition_with_ids_;
}
inline const ::dingodb::pb::meta::TableDefinitionWithId& GetTablesResponse::_internal_table_definition_with_ids(int index) const {
  return _impl_.table_definition_with_ids_.Get(index);
}
inline const ::dingodb::pb::meta::TableDefinitionWithId& GetTablesResponse::table_definition_with_ids(int index) const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.GetTablesResponse.table_definition_with_ids)
  return _internal_table_definition_with_ids(index);
}
inline ::dingodb::pb::meta::TableDefinitionWithId* GetTablesResponse::_internal_add_table_definition_with_ids() {
  return _impl_.table_definition_with_ids_.Add();
}
inline ::dingodb::pb::meta::TableDefinitionWithId* GetTablesResponse::add_table_definition_with_ids() {
  ::dingodb::pb::meta::TableDefinitionWithId* _add = _internal_add_table_definition_with_ids();
  // @@protoc_insertion_point(field_add:dingodb.pb.meta.GetTablesResponse.table_definition_with_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::meta::TableDefinitionWithId >&
GetTablesResponse::table_definition_with_ids() const {
  // @@protoc_insertion_point(field_list:dingodb.pb.meta.GetTablesResponse.table_definition_with_ids)
  return _impl_.table_definition_with_ids_;
}

// -------------------------------------------------------------------

// GetTableRequest

// .dingodb.pb.meta.DingoCommonId table_id = 1 [json_name = "tableId"];
inline bool GetTableRequest::_internal_has_table_id() const {
  return this != internal_default_instance() && _impl_.table_id_ != nullptr;
}
inline bool GetTableRequest::has_table_id() const {
  return _internal_has_table_id();
}
inline void GetTableRequest::clear_table_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_id_ != nullptr) {
    delete _impl_.table_id_;
  }
  _impl_.table_id_ = nullptr;
}
inline const ::dingodb::pb::meta::DingoCommonId& GetTableRequest::_internal_table_id() const {
  const ::dingodb::pb::meta::DingoCommonId* p = _impl_.table_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::DingoCommonId&>(
      ::dingodb::pb::meta::_DingoCommonId_default_instance_);
}
inline const ::dingodb::pb::meta::DingoCommonId& GetTableRequest::table_id() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.GetTableRequest.table_id)
  return _internal_table_id();
}
inline void GetTableRequest::unsafe_arena_set_allocated_table_id(
    ::dingodb::pb::meta::DingoCommonId* table_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_id_);
  }
  _impl_.table_id_ = table_id;
  if (table_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.GetTableRequest.table_id)
}
inline ::dingodb::pb::meta::DingoCommonId* GetTableRequest::release_table_id() {
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* GetTableRequest::unsafe_arena_release_table_id() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.GetTableRequest.table_id)
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* GetTableRequest::_internal_mutable_table_id() {
  
  if (_impl_.table_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::DingoCommonId>(GetArenaForAllocation());
    _impl_.table_id_ = p;
  }
  return _impl_.table_id_;
}
inline ::dingodb::pb::meta::DingoCommonId* GetTableRequest::mutable_table_id() {
  ::dingodb::pb::meta::DingoCommonId* _msg = _internal_mutable_table_id();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.GetTableRequest.table_id)
  return _msg;
}
inline void GetTableRequest::set_allocated_table_id(::dingodb::pb::meta::DingoCommonId* table_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_id_;
  }
  if (table_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_id);
    if (message_arena != submessage_arena) {
      table_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_id_ = table_id;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.GetTableRequest.table_id)
}

// -------------------------------------------------------------------

// GetTableResponse

// .dingodb.pb.error.Error error = 1 [json_name = "error"];
inline bool GetTableResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool GetTableResponse::has_error() const {
  return _internal_has_error();
}
inline const ::dingodb::pb::error::Error& GetTableResponse::_internal_error() const {
  const ::dingodb::pb::error::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::error::Error&>(
      ::dingodb::pb::error::_Error_default_instance_);
}
inline const ::dingodb::pb::error::Error& GetTableResponse::error() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.GetTableResponse.error)
  return _internal_error();
}
inline void GetTableResponse::unsafe_arena_set_allocated_error(
    ::dingodb::pb::error::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.GetTableResponse.error)
}
inline ::dingodb::pb::error::Error* GetTableResponse::release_error() {
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::error::Error* GetTableResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.GetTableResponse.error)
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::dingodb::pb::error::Error* GetTableResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::error::Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::dingodb::pb::error::Error* GetTableResponse::mutable_error() {
  ::dingodb::pb::error::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.GetTableResponse.error)
  return _msg;
}
inline void GetTableResponse::set_allocated_error(::dingodb::pb::error::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.GetTableResponse.error)
}

// .dingodb.pb.meta.Table table = 2 [json_name = "table"];
inline bool GetTableResponse::_internal_has_table() const {
  return this != internal_default_instance() && _impl_.table_ != nullptr;
}
inline bool GetTableResponse::has_table() const {
  return _internal_has_table();
}
inline void GetTableResponse::clear_table() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_ != nullptr) {
    delete _impl_.table_;
  }
  _impl_.table_ = nullptr;
}
inline const ::dingodb::pb::meta::Table& GetTableResponse::_internal_table() const {
  const ::dingodb::pb::meta::Table* p = _impl_.table_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::Table&>(
      ::dingodb::pb::meta::_Table_default_instance_);
}
inline const ::dingodb::pb::meta::Table& GetTableResponse::table() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.GetTableResponse.table)
  return _internal_table();
}
inline void GetTableResponse::unsafe_arena_set_allocated_table(
    ::dingodb::pb::meta::Table* table) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_);
  }
  _impl_.table_ = table;
  if (table) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.GetTableResponse.table)
}
inline ::dingodb::pb::meta::Table* GetTableResponse::release_table() {
  
  ::dingodb::pb::meta::Table* temp = _impl_.table_;
  _impl_.table_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::Table* GetTableResponse::unsafe_arena_release_table() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.GetTableResponse.table)
  
  ::dingodb::pb::meta::Table* temp = _impl_.table_;
  _impl_.table_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::Table* GetTableResponse::_internal_mutable_table() {
  
  if (_impl_.table_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::Table>(GetArenaForAllocation());
    _impl_.table_ = p;
  }
  return _impl_.table_;
}
inline ::dingodb::pb::meta::Table* GetTableResponse::mutable_table() {
  ::dingodb::pb::meta::Table* _msg = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.GetTableResponse.table)
  return _msg;
}
inline void GetTableResponse::set_allocated_table(::dingodb::pb::meta::Table* table) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_;
  }
  if (table) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table);
    if (message_arena != submessage_arena) {
      table = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_ = table;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.GetTableResponse.table)
}

// -------------------------------------------------------------------

// CreateTableRequest

// .dingodb.pb.meta.DingoCommonId schema_id = 1 [json_name = "schemaId"];
inline bool CreateTableRequest::_internal_has_schema_id() const {
  return this != internal_default_instance() && _impl_.schema_id_ != nullptr;
}
inline bool CreateTableRequest::has_schema_id() const {
  return _internal_has_schema_id();
}
inline void CreateTableRequest::clear_schema_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.schema_id_ != nullptr) {
    delete _impl_.schema_id_;
  }
  _impl_.schema_id_ = nullptr;
}
inline const ::dingodb::pb::meta::DingoCommonId& CreateTableRequest::_internal_schema_id() const {
  const ::dingodb::pb::meta::DingoCommonId* p = _impl_.schema_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::DingoCommonId&>(
      ::dingodb::pb::meta::_DingoCommonId_default_instance_);
}
inline const ::dingodb::pb::meta::DingoCommonId& CreateTableRequest::schema_id() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.CreateTableRequest.schema_id)
  return _internal_schema_id();
}
inline void CreateTableRequest::unsafe_arena_set_allocated_schema_id(
    ::dingodb::pb::meta::DingoCommonId* schema_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_id_);
  }
  _impl_.schema_id_ = schema_id;
  if (schema_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.CreateTableRequest.schema_id)
}
inline ::dingodb::pb::meta::DingoCommonId* CreateTableRequest::release_schema_id() {
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.schema_id_;
  _impl_.schema_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* CreateTableRequest::unsafe_arena_release_schema_id() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.CreateTableRequest.schema_id)
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.schema_id_;
  _impl_.schema_id_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* CreateTableRequest::_internal_mutable_schema_id() {
  
  if (_impl_.schema_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::DingoCommonId>(GetArenaForAllocation());
    _impl_.schema_id_ = p;
  }
  return _impl_.schema_id_;
}
inline ::dingodb::pb::meta::DingoCommonId* CreateTableRequest::mutable_schema_id() {
  ::dingodb::pb::meta::DingoCommonId* _msg = _internal_mutable_schema_id();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.CreateTableRequest.schema_id)
  return _msg;
}
inline void CreateTableRequest::set_allocated_schema_id(::dingodb::pb::meta::DingoCommonId* schema_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schema_id_;
  }
  if (schema_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schema_id);
    if (message_arena != submessage_arena) {
      schema_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.schema_id_ = schema_id;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.CreateTableRequest.schema_id)
}

// .dingodb.pb.meta.TableDefinition table_definition = 2 [json_name = "tableDefinition"];
inline bool CreateTableRequest::_internal_has_table_definition() const {
  return this != internal_default_instance() && _impl_.table_definition_ != nullptr;
}
inline bool CreateTableRequest::has_table_definition() const {
  return _internal_has_table_definition();
}
inline void CreateTableRequest::clear_table_definition() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_definition_ != nullptr) {
    delete _impl_.table_definition_;
  }
  _impl_.table_definition_ = nullptr;
}
inline const ::dingodb::pb::meta::TableDefinition& CreateTableRequest::_internal_table_definition() const {
  const ::dingodb::pb::meta::TableDefinition* p = _impl_.table_definition_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::TableDefinition&>(
      ::dingodb::pb::meta::_TableDefinition_default_instance_);
}
inline const ::dingodb::pb::meta::TableDefinition& CreateTableRequest::table_definition() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.CreateTableRequest.table_definition)
  return _internal_table_definition();
}
inline void CreateTableRequest::unsafe_arena_set_allocated_table_definition(
    ::dingodb::pb::meta::TableDefinition* table_definition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_definition_);
  }
  _impl_.table_definition_ = table_definition;
  if (table_definition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.CreateTableRequest.table_definition)
}
inline ::dingodb::pb::meta::TableDefinition* CreateTableRequest::release_table_definition() {
  
  ::dingodb::pb::meta::TableDefinition* temp = _impl_.table_definition_;
  _impl_.table_definition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::TableDefinition* CreateTableRequest::unsafe_arena_release_table_definition() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.CreateTableRequest.table_definition)
  
  ::dingodb::pb::meta::TableDefinition* temp = _impl_.table_definition_;
  _impl_.table_definition_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::TableDefinition* CreateTableRequest::_internal_mutable_table_definition() {
  
  if (_impl_.table_definition_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::TableDefinition>(GetArenaForAllocation());
    _impl_.table_definition_ = p;
  }
  return _impl_.table_definition_;
}
inline ::dingodb::pb::meta::TableDefinition* CreateTableRequest::mutable_table_definition() {
  ::dingodb::pb::meta::TableDefinition* _msg = _internal_mutable_table_definition();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.CreateTableRequest.table_definition)
  return _msg;
}
inline void CreateTableRequest::set_allocated_table_definition(::dingodb::pb::meta::TableDefinition* table_definition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_definition_;
  }
  if (table_definition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_definition);
    if (message_arena != submessage_arena) {
      table_definition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_definition, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_definition_ = table_definition;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.CreateTableRequest.table_definition)
}

// -------------------------------------------------------------------

// CreateTableResponse

// .dingodb.pb.error.Error error = 1 [json_name = "error"];
inline bool CreateTableResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool CreateTableResponse::has_error() const {
  return _internal_has_error();
}
inline const ::dingodb::pb::error::Error& CreateTableResponse::_internal_error() const {
  const ::dingodb::pb::error::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::error::Error&>(
      ::dingodb::pb::error::_Error_default_instance_);
}
inline const ::dingodb::pb::error::Error& CreateTableResponse::error() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.CreateTableResponse.error)
  return _internal_error();
}
inline void CreateTableResponse::unsafe_arena_set_allocated_error(
    ::dingodb::pb::error::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.CreateTableResponse.error)
}
inline ::dingodb::pb::error::Error* CreateTableResponse::release_error() {
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::error::Error* CreateTableResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.CreateTableResponse.error)
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::dingodb::pb::error::Error* CreateTableResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::error::Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::dingodb::pb::error::Error* CreateTableResponse::mutable_error() {
  ::dingodb::pb::error::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.CreateTableResponse.error)
  return _msg;
}
inline void CreateTableResponse::set_allocated_error(::dingodb::pb::error::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.CreateTableResponse.error)
}

// .dingodb.pb.meta.Table table = 2 [json_name = "table"];
inline bool CreateTableResponse::_internal_has_table() const {
  return this != internal_default_instance() && _impl_.table_ != nullptr;
}
inline bool CreateTableResponse::has_table() const {
  return _internal_has_table();
}
inline void CreateTableResponse::clear_table() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_ != nullptr) {
    delete _impl_.table_;
  }
  _impl_.table_ = nullptr;
}
inline const ::dingodb::pb::meta::Table& CreateTableResponse::_internal_table() const {
  const ::dingodb::pb::meta::Table* p = _impl_.table_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::Table&>(
      ::dingodb::pb::meta::_Table_default_instance_);
}
inline const ::dingodb::pb::meta::Table& CreateTableResponse::table() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.CreateTableResponse.table)
  return _internal_table();
}
inline void CreateTableResponse::unsafe_arena_set_allocated_table(
    ::dingodb::pb::meta::Table* table) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_);
  }
  _impl_.table_ = table;
  if (table) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.CreateTableResponse.table)
}
inline ::dingodb::pb::meta::Table* CreateTableResponse::release_table() {
  
  ::dingodb::pb::meta::Table* temp = _impl_.table_;
  _impl_.table_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::Table* CreateTableResponse::unsafe_arena_release_table() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.CreateTableResponse.table)
  
  ::dingodb::pb::meta::Table* temp = _impl_.table_;
  _impl_.table_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::Table* CreateTableResponse::_internal_mutable_table() {
  
  if (_impl_.table_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::Table>(GetArenaForAllocation());
    _impl_.table_ = p;
  }
  return _impl_.table_;
}
inline ::dingodb::pb::meta::Table* CreateTableResponse::mutable_table() {
  ::dingodb::pb::meta::Table* _msg = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.CreateTableResponse.table)
  return _msg;
}
inline void CreateTableResponse::set_allocated_table(::dingodb::pb::meta::Table* table) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_;
  }
  if (table) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table);
    if (message_arena != submessage_arena) {
      table = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_ = table;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.CreateTableResponse.table)
}

// -------------------------------------------------------------------

// CreateSchemaRequest

// .dingodb.pb.meta.DingoCommonId parent_schema_id = 1 [json_name = "parentSchemaId"];
inline bool CreateSchemaRequest::_internal_has_parent_schema_id() const {
  return this != internal_default_instance() && _impl_.parent_schema_id_ != nullptr;
}
inline bool CreateSchemaRequest::has_parent_schema_id() const {
  return _internal_has_parent_schema_id();
}
inline void CreateSchemaRequest::clear_parent_schema_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.parent_schema_id_ != nullptr) {
    delete _impl_.parent_schema_id_;
  }
  _impl_.parent_schema_id_ = nullptr;
}
inline const ::dingodb::pb::meta::DingoCommonId& CreateSchemaRequest::_internal_parent_schema_id() const {
  const ::dingodb::pb::meta::DingoCommonId* p = _impl_.parent_schema_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::DingoCommonId&>(
      ::dingodb::pb::meta::_DingoCommonId_default_instance_);
}
inline const ::dingodb::pb::meta::DingoCommonId& CreateSchemaRequest::parent_schema_id() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.CreateSchemaRequest.parent_schema_id)
  return _internal_parent_schema_id();
}
inline void CreateSchemaRequest::unsafe_arena_set_allocated_parent_schema_id(
    ::dingodb::pb::meta::DingoCommonId* parent_schema_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_schema_id_);
  }
  _impl_.parent_schema_id_ = parent_schema_id;
  if (parent_schema_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.CreateSchemaRequest.parent_schema_id)
}
inline ::dingodb::pb::meta::DingoCommonId* CreateSchemaRequest::release_parent_schema_id() {
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.parent_schema_id_;
  _impl_.parent_schema_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* CreateSchemaRequest::unsafe_arena_release_parent_schema_id() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.CreateSchemaRequest.parent_schema_id)
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.parent_schema_id_;
  _impl_.parent_schema_id_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* CreateSchemaRequest::_internal_mutable_parent_schema_id() {
  
  if (_impl_.parent_schema_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::DingoCommonId>(GetArenaForAllocation());
    _impl_.parent_schema_id_ = p;
  }
  return _impl_.parent_schema_id_;
}
inline ::dingodb::pb::meta::DingoCommonId* CreateSchemaRequest::mutable_parent_schema_id() {
  ::dingodb::pb::meta::DingoCommonId* _msg = _internal_mutable_parent_schema_id();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.CreateSchemaRequest.parent_schema_id)
  return _msg;
}
inline void CreateSchemaRequest::set_allocated_parent_schema_id(::dingodb::pb::meta::DingoCommonId* parent_schema_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_schema_id_;
  }
  if (parent_schema_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent_schema_id);
    if (message_arena != submessage_arena) {
      parent_schema_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent_schema_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.parent_schema_id_ = parent_schema_id;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.CreateSchemaRequest.parent_schema_id)
}

// string schema_name = 2 [json_name = "schemaName"];
inline void CreateSchemaRequest::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& CreateSchemaRequest::schema_name() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.CreateSchemaRequest.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSchemaRequest::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dingodb.pb.meta.CreateSchemaRequest.schema_name)
}
inline std::string* CreateSchemaRequest::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.CreateSchemaRequest.schema_name)
  return _s;
}
inline const std::string& CreateSchemaRequest::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void CreateSchemaRequest::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateSchemaRequest::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateSchemaRequest::release_schema_name() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.CreateSchemaRequest.schema_name)
  return _impl_.schema_name_.Release();
}
inline void CreateSchemaRequest::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.CreateSchemaRequest.schema_name)
}

// -------------------------------------------------------------------

// CreateSchemaResponse

// .dingodb.pb.error.Error error = 1 [json_name = "error"];
inline bool CreateSchemaResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool CreateSchemaResponse::has_error() const {
  return _internal_has_error();
}
inline const ::dingodb::pb::error::Error& CreateSchemaResponse::_internal_error() const {
  const ::dingodb::pb::error::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::error::Error&>(
      ::dingodb::pb::error::_Error_default_instance_);
}
inline const ::dingodb::pb::error::Error& CreateSchemaResponse::error() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.CreateSchemaResponse.error)
  return _internal_error();
}
inline void CreateSchemaResponse::unsafe_arena_set_allocated_error(
    ::dingodb::pb::error::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.CreateSchemaResponse.error)
}
inline ::dingodb::pb::error::Error* CreateSchemaResponse::release_error() {
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::error::Error* CreateSchemaResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.CreateSchemaResponse.error)
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::dingodb::pb::error::Error* CreateSchemaResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::error::Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::dingodb::pb::error::Error* CreateSchemaResponse::mutable_error() {
  ::dingodb::pb::error::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.CreateSchemaResponse.error)
  return _msg;
}
inline void CreateSchemaResponse::set_allocated_error(::dingodb::pb::error::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.CreateSchemaResponse.error)
}

// .dingodb.pb.meta.Schema schema = 2 [json_name = "schema"];
inline bool CreateSchemaResponse::_internal_has_schema() const {
  return this != internal_default_instance() && _impl_.schema_ != nullptr;
}
inline bool CreateSchemaResponse::has_schema() const {
  return _internal_has_schema();
}
inline void CreateSchemaResponse::clear_schema() {
  if (GetArenaForAllocation() == nullptr && _impl_.schema_ != nullptr) {
    delete _impl_.schema_;
  }
  _impl_.schema_ = nullptr;
}
inline const ::dingodb::pb::meta::Schema& CreateSchemaResponse::_internal_schema() const {
  const ::dingodb::pb::meta::Schema* p = _impl_.schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::Schema&>(
      ::dingodb::pb::meta::_Schema_default_instance_);
}
inline const ::dingodb::pb::meta::Schema& CreateSchemaResponse::schema() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.CreateSchemaResponse.schema)
  return _internal_schema();
}
inline void CreateSchemaResponse::unsafe_arena_set_allocated_schema(
    ::dingodb::pb::meta::Schema* schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_);
  }
  _impl_.schema_ = schema;
  if (schema) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.CreateSchemaResponse.schema)
}
inline ::dingodb::pb::meta::Schema* CreateSchemaResponse::release_schema() {
  
  ::dingodb::pb::meta::Schema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::Schema* CreateSchemaResponse::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.CreateSchemaResponse.schema)
  
  ::dingodb::pb::meta::Schema* temp = _impl_.schema_;
  _impl_.schema_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::Schema* CreateSchemaResponse::_internal_mutable_schema() {
  
  if (_impl_.schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::Schema>(GetArenaForAllocation());
    _impl_.schema_ = p;
  }
  return _impl_.schema_;
}
inline ::dingodb::pb::meta::Schema* CreateSchemaResponse::mutable_schema() {
  ::dingodb::pb::meta::Schema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.CreateSchemaResponse.schema)
  return _msg;
}
inline void CreateSchemaResponse::set_allocated_schema(::dingodb::pb::meta::Schema* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schema_;
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schema);
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.CreateSchemaResponse.schema)
}

// -------------------------------------------------------------------

// DropTableRequest

// .dingodb.pb.meta.DingoCommonId table_id = 1 [json_name = "tableId"];
inline bool DropTableRequest::_internal_has_table_id() const {
  return this != internal_default_instance() && _impl_.table_id_ != nullptr;
}
inline bool DropTableRequest::has_table_id() const {
  return _internal_has_table_id();
}
inline void DropTableRequest::clear_table_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.table_id_ != nullptr) {
    delete _impl_.table_id_;
  }
  _impl_.table_id_ = nullptr;
}
inline const ::dingodb::pb::meta::DingoCommonId& DropTableRequest::_internal_table_id() const {
  const ::dingodb::pb::meta::DingoCommonId* p = _impl_.table_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::meta::DingoCommonId&>(
      ::dingodb::pb::meta::_DingoCommonId_default_instance_);
}
inline const ::dingodb::pb::meta::DingoCommonId& DropTableRequest::table_id() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.DropTableRequest.table_id)
  return _internal_table_id();
}
inline void DropTableRequest::unsafe_arena_set_allocated_table_id(
    ::dingodb::pb::meta::DingoCommonId* table_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_id_);
  }
  _impl_.table_id_ = table_id;
  if (table_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.DropTableRequest.table_id)
}
inline ::dingodb::pb::meta::DingoCommonId* DropTableRequest::release_table_id() {
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* DropTableRequest::unsafe_arena_release_table_id() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.DropTableRequest.table_id)
  
  ::dingodb::pb::meta::DingoCommonId* temp = _impl_.table_id_;
  _impl_.table_id_ = nullptr;
  return temp;
}
inline ::dingodb::pb::meta::DingoCommonId* DropTableRequest::_internal_mutable_table_id() {
  
  if (_impl_.table_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::meta::DingoCommonId>(GetArenaForAllocation());
    _impl_.table_id_ = p;
  }
  return _impl_.table_id_;
}
inline ::dingodb::pb::meta::DingoCommonId* DropTableRequest::mutable_table_id() {
  ::dingodb::pb::meta::DingoCommonId* _msg = _internal_mutable_table_id();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.DropTableRequest.table_id)
  return _msg;
}
inline void DropTableRequest::set_allocated_table_id(::dingodb::pb::meta::DingoCommonId* table_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_id_;
  }
  if (table_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_id);
    if (message_arena != submessage_arena) {
      table_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.table_id_ = table_id;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.DropTableRequest.table_id)
}

// -------------------------------------------------------------------

// DropTableResponse

// .dingodb.pb.error.Error error = 1 [json_name = "error"];
inline bool DropTableResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool DropTableResponse::has_error() const {
  return _internal_has_error();
}
inline const ::dingodb::pb::error::Error& DropTableResponse::_internal_error() const {
  const ::dingodb::pb::error::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::error::Error&>(
      ::dingodb::pb::error::_Error_default_instance_);
}
inline const ::dingodb::pb::error::Error& DropTableResponse::error() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.meta.DropTableResponse.error)
  return _internal_error();
}
inline void DropTableResponse::unsafe_arena_set_allocated_error(
    ::dingodb::pb::error::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.meta.DropTableResponse.error)
}
inline ::dingodb::pb::error::Error* DropTableResponse::release_error() {
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::error::Error* DropTableResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:dingodb.pb.meta.DropTableResponse.error)
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::dingodb::pb::error::Error* DropTableResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::error::Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::dingodb::pb::error::Error* DropTableResponse::mutable_error() {
  ::dingodb::pb::error::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.meta.DropTableResponse.error)
  return _msg;
}
inline void DropTableResponse::set_allocated_error(::dingodb::pb::error::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.meta.DropTableResponse.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace meta
}  // namespace pb
}  // namespace dingodb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::dingodb::pb::meta::EntityType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dingodb::pb::meta::EntityType>() {
  return ::dingodb::pb::meta::EntityType_descriptor();
}
template <> struct is_proto_enum< ::dingodb::pb::meta::ReservedSchemaIds> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dingodb::pb::meta::ReservedSchemaIds>() {
  return ::dingodb::pb::meta::ReservedSchemaIds_descriptor();
}
template <> struct is_proto_enum< ::dingodb::pb::meta::SqlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dingodb::pb::meta::SqlType>() {
  return ::dingodb::pb::meta::SqlType_descriptor();
}
template <> struct is_proto_enum< ::dingodb::pb::meta::ElementType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dingodb::pb::meta::ElementType>() {
  return ::dingodb::pb::meta::ElementType_descriptor();
}
template <> struct is_proto_enum< ::dingodb::pb::meta::PartitionStrategy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dingodb::pb::meta::PartitionStrategy>() {
  return ::dingodb::pb::meta::PartitionStrategy_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_meta_2eproto
