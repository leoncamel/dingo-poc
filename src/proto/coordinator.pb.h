// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: coordinator.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_coordinator_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_coordinator_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "error.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_coordinator_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_coordinator_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_coordinator_2eproto;
namespace dingodb {
namespace pb {
namespace coordinator {
class CreateStoreRequest;
struct CreateStoreRequestDefaultTypeInternal;
extern CreateStoreRequestDefaultTypeInternal _CreateStoreRequest_default_instance_;
class CreateStoreResponse;
struct CreateStoreResponseDefaultTypeInternal;
extern CreateStoreResponseDefaultTypeInternal _CreateStoreResponse_default_instance_;
class GetRegionMapRequest;
struct GetRegionMapRequestDefaultTypeInternal;
extern GetRegionMapRequestDefaultTypeInternal _GetRegionMapRequest_default_instance_;
class GetRegionMapResponse;
struct GetRegionMapResponseDefaultTypeInternal;
extern GetRegionMapResponseDefaultTypeInternal _GetRegionMapResponse_default_instance_;
class GetStoreMapRequest;
struct GetStoreMapRequestDefaultTypeInternal;
extern GetStoreMapRequestDefaultTypeInternal _GetStoreMapRequest_default_instance_;
class GetStoreMapResponse;
struct GetStoreMapResponseDefaultTypeInternal;
extern GetStoreMapResponseDefaultTypeInternal _GetStoreMapResponse_default_instance_;
class HelloRequest;
struct HelloRequestDefaultTypeInternal;
extern HelloRequestDefaultTypeInternal _HelloRequest_default_instance_;
class HelloResponse;
struct HelloResponseDefaultTypeInternal;
extern HelloResponseDefaultTypeInternal _HelloResponse_default_instance_;
class StoreHeartbeatRequest;
struct StoreHeartbeatRequestDefaultTypeInternal;
extern StoreHeartbeatRequestDefaultTypeInternal _StoreHeartbeatRequest_default_instance_;
class StoreHeartbeatResponse;
struct StoreHeartbeatResponseDefaultTypeInternal;
extern StoreHeartbeatResponseDefaultTypeInternal _StoreHeartbeatResponse_default_instance_;
}  // namespace coordinator
}  // namespace pb
}  // namespace dingodb
PROTOBUF_NAMESPACE_OPEN
template<> ::dingodb::pb::coordinator::CreateStoreRequest* Arena::CreateMaybeMessage<::dingodb::pb::coordinator::CreateStoreRequest>(Arena*);
template<> ::dingodb::pb::coordinator::CreateStoreResponse* Arena::CreateMaybeMessage<::dingodb::pb::coordinator::CreateStoreResponse>(Arena*);
template<> ::dingodb::pb::coordinator::GetRegionMapRequest* Arena::CreateMaybeMessage<::dingodb::pb::coordinator::GetRegionMapRequest>(Arena*);
template<> ::dingodb::pb::coordinator::GetRegionMapResponse* Arena::CreateMaybeMessage<::dingodb::pb::coordinator::GetRegionMapResponse>(Arena*);
template<> ::dingodb::pb::coordinator::GetStoreMapRequest* Arena::CreateMaybeMessage<::dingodb::pb::coordinator::GetStoreMapRequest>(Arena*);
template<> ::dingodb::pb::coordinator::GetStoreMapResponse* Arena::CreateMaybeMessage<::dingodb::pb::coordinator::GetStoreMapResponse>(Arena*);
template<> ::dingodb::pb::coordinator::HelloRequest* Arena::CreateMaybeMessage<::dingodb::pb::coordinator::HelloRequest>(Arena*);
template<> ::dingodb::pb::coordinator::HelloResponse* Arena::CreateMaybeMessage<::dingodb::pb::coordinator::HelloResponse>(Arena*);
template<> ::dingodb::pb::coordinator::StoreHeartbeatRequest* Arena::CreateMaybeMessage<::dingodb::pb::coordinator::StoreHeartbeatRequest>(Arena*);
template<> ::dingodb::pb::coordinator::StoreHeartbeatResponse* Arena::CreateMaybeMessage<::dingodb::pb::coordinator::StoreHeartbeatResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace dingodb {
namespace pb {
namespace coordinator {

// ===================================================================

class StoreHeartbeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.coordinator.StoreHeartbeatRequest) */ {
 public:
  inline StoreHeartbeatRequest() : StoreHeartbeatRequest(nullptr) {}
  ~StoreHeartbeatRequest() override;
  explicit PROTOBUF_CONSTEXPR StoreHeartbeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreHeartbeatRequest(const StoreHeartbeatRequest& from);
  StoreHeartbeatRequest(StoreHeartbeatRequest&& from) noexcept
    : StoreHeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline StoreHeartbeatRequest& operator=(const StoreHeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreHeartbeatRequest& operator=(StoreHeartbeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreHeartbeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreHeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const StoreHeartbeatRequest*>(
               &_StoreHeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StoreHeartbeatRequest& a, StoreHeartbeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreHeartbeatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreHeartbeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreHeartbeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreHeartbeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreHeartbeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StoreHeartbeatRequest& from) {
    StoreHeartbeatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreHeartbeatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.coordinator.StoreHeartbeatRequest";
  }
  protected:
  explicit StoreHeartbeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionsFieldNumber = 4,
    kStoreFieldNumber = 3,
    kSelfStoremapEpochFieldNumber = 1,
    kSelfRegionmapEpochFieldNumber = 2,
  };
  // repeated .dingodb.pb.common.Region regions = 4 [json_name = "regions"];
  int regions_size() const;
  private:
  int _internal_regions_size() const;
  public:
  void clear_regions();
  ::dingodb::pb::common::Region* mutable_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Region >*
      mutable_regions();
  private:
  const ::dingodb::pb::common::Region& _internal_regions(int index) const;
  ::dingodb::pb::common::Region* _internal_add_regions();
  public:
  const ::dingodb::pb::common::Region& regions(int index) const;
  ::dingodb::pb::common::Region* add_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Region >&
      regions() const;

  // .dingodb.pb.common.Store store = 3 [json_name = "store"];
  bool has_store() const;
  private:
  bool _internal_has_store() const;
  public:
  void clear_store();
  const ::dingodb::pb::common::Store& store() const;
  PROTOBUF_NODISCARD ::dingodb::pb::common::Store* release_store();
  ::dingodb::pb::common::Store* mutable_store();
  void set_allocated_store(::dingodb::pb::common::Store* store);
  private:
  const ::dingodb::pb::common::Store& _internal_store() const;
  ::dingodb::pb::common::Store* _internal_mutable_store();
  public:
  void unsafe_arena_set_allocated_store(
      ::dingodb::pb::common::Store* store);
  ::dingodb::pb::common::Store* unsafe_arena_release_store();

  // uint64 self_storemap_epoch = 1 [json_name = "selfStoremapEpoch"];
  void clear_self_storemap_epoch();
  uint64_t self_storemap_epoch() const;
  void set_self_storemap_epoch(uint64_t value);
  private:
  uint64_t _internal_self_storemap_epoch() const;
  void _internal_set_self_storemap_epoch(uint64_t value);
  public:

  // uint64 self_regionmap_epoch = 2 [json_name = "selfRegionmapEpoch"];
  void clear_self_regionmap_epoch();
  uint64_t self_regionmap_epoch() const;
  void set_self_regionmap_epoch(uint64_t value);
  private:
  uint64_t _internal_self_regionmap_epoch() const;
  void _internal_set_self_regionmap_epoch(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.coordinator.StoreHeartbeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Region > regions_;
    ::dingodb::pb::common::Store* store_;
    uint64_t self_storemap_epoch_;
    uint64_t self_regionmap_epoch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coordinator_2eproto;
};
// -------------------------------------------------------------------

class StoreHeartbeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.coordinator.StoreHeartbeatResponse) */ {
 public:
  inline StoreHeartbeatResponse() : StoreHeartbeatResponse(nullptr) {}
  ~StoreHeartbeatResponse() override;
  explicit PROTOBUF_CONSTEXPR StoreHeartbeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreHeartbeatResponse(const StoreHeartbeatResponse& from);
  StoreHeartbeatResponse(StoreHeartbeatResponse&& from) noexcept
    : StoreHeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline StoreHeartbeatResponse& operator=(const StoreHeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreHeartbeatResponse& operator=(StoreHeartbeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreHeartbeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreHeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const StoreHeartbeatResponse*>(
               &_StoreHeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StoreHeartbeatResponse& a, StoreHeartbeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreHeartbeatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreHeartbeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreHeartbeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreHeartbeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreHeartbeatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StoreHeartbeatResponse& from) {
    StoreHeartbeatResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreHeartbeatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.coordinator.StoreHeartbeatResponse";
  }
  protected:
  explicit StoreHeartbeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kStoremapFieldNumber = 4,
    kRegionmapFieldNumber = 5,
    kStoremapEpochFieldNumber = 2,
    kRegionmapEpochFieldNumber = 3,
  };
  // .dingodb.pb.error.Error error = 1 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::dingodb::pb::error::Error& error() const;
  PROTOBUF_NODISCARD ::dingodb::pb::error::Error* release_error();
  ::dingodb::pb::error::Error* mutable_error();
  void set_allocated_error(::dingodb::pb::error::Error* error);
  private:
  const ::dingodb::pb::error::Error& _internal_error() const;
  ::dingodb::pb::error::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::dingodb::pb::error::Error* error);
  ::dingodb::pb::error::Error* unsafe_arena_release_error();

  // .dingodb.pb.common.StoreMap storemap = 4 [json_name = "storemap"];
  bool has_storemap() const;
  private:
  bool _internal_has_storemap() const;
  public:
  void clear_storemap();
  const ::dingodb::pb::common::StoreMap& storemap() const;
  PROTOBUF_NODISCARD ::dingodb::pb::common::StoreMap* release_storemap();
  ::dingodb::pb::common::StoreMap* mutable_storemap();
  void set_allocated_storemap(::dingodb::pb::common::StoreMap* storemap);
  private:
  const ::dingodb::pb::common::StoreMap& _internal_storemap() const;
  ::dingodb::pb::common::StoreMap* _internal_mutable_storemap();
  public:
  void unsafe_arena_set_allocated_storemap(
      ::dingodb::pb::common::StoreMap* storemap);
  ::dingodb::pb::common::StoreMap* unsafe_arena_release_storemap();

  // .dingodb.pb.common.RegionMap regionmap = 5 [json_name = "regionmap"];
  bool has_regionmap() const;
  private:
  bool _internal_has_regionmap() const;
  public:
  void clear_regionmap();
  const ::dingodb::pb::common::RegionMap& regionmap() const;
  PROTOBUF_NODISCARD ::dingodb::pb::common::RegionMap* release_regionmap();
  ::dingodb::pb::common::RegionMap* mutable_regionmap();
  void set_allocated_regionmap(::dingodb::pb::common::RegionMap* regionmap);
  private:
  const ::dingodb::pb::common::RegionMap& _internal_regionmap() const;
  ::dingodb::pb::common::RegionMap* _internal_mutable_regionmap();
  public:
  void unsafe_arena_set_allocated_regionmap(
      ::dingodb::pb::common::RegionMap* regionmap);
  ::dingodb::pb::common::RegionMap* unsafe_arena_release_regionmap();

  // uint64 storemap_epoch = 2 [json_name = "storemapEpoch"];
  void clear_storemap_epoch();
  uint64_t storemap_epoch() const;
  void set_storemap_epoch(uint64_t value);
  private:
  uint64_t _internal_storemap_epoch() const;
  void _internal_set_storemap_epoch(uint64_t value);
  public:

  // uint64 regionmap_epoch = 3 [json_name = "regionmapEpoch"];
  void clear_regionmap_epoch();
  uint64_t regionmap_epoch() const;
  void set_regionmap_epoch(uint64_t value);
  private:
  uint64_t _internal_regionmap_epoch() const;
  void _internal_set_regionmap_epoch(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.coordinator.StoreHeartbeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dingodb::pb::error::Error* error_;
    ::dingodb::pb::common::StoreMap* storemap_;
    ::dingodb::pb::common::RegionMap* regionmap_;
    uint64_t storemap_epoch_;
    uint64_t regionmap_epoch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coordinator_2eproto;
};
// -------------------------------------------------------------------

class HelloRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.coordinator.HelloRequest) */ {
 public:
  inline HelloRequest() : HelloRequest(nullptr) {}
  ~HelloRequest() override;
  explicit PROTOBUF_CONSTEXPR HelloRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloRequest(const HelloRequest& from);
  HelloRequest(HelloRequest&& from) noexcept
    : HelloRequest() {
    *this = ::std::move(from);
  }

  inline HelloRequest& operator=(const HelloRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloRequest& operator=(HelloRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloRequest* internal_default_instance() {
    return reinterpret_cast<const HelloRequest*>(
               &_HelloRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HelloRequest& a, HelloRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HelloRequest& from) {
    HelloRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.coordinator.HelloRequest";
  }
  protected:
  explicit HelloRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHelloFieldNumber = 1,
  };
  // uint64 hello = 1 [json_name = "hello"];
  void clear_hello();
  uint64_t hello() const;
  void set_hello(uint64_t value);
  private:
  uint64_t _internal_hello() const;
  void _internal_set_hello(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.coordinator.HelloRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t hello_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coordinator_2eproto;
};
// -------------------------------------------------------------------

class HelloResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.coordinator.HelloResponse) */ {
 public:
  inline HelloResponse() : HelloResponse(nullptr) {}
  ~HelloResponse() override;
  explicit PROTOBUF_CONSTEXPR HelloResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloResponse(const HelloResponse& from);
  HelloResponse(HelloResponse&& from) noexcept
    : HelloResponse() {
    *this = ::std::move(from);
  }

  inline HelloResponse& operator=(const HelloResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloResponse& operator=(HelloResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloResponse* internal_default_instance() {
    return reinterpret_cast<const HelloResponse*>(
               &_HelloResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HelloResponse& a, HelloResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HelloResponse& from) {
    HelloResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.coordinator.HelloResponse";
  }
  protected:
  explicit HelloResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusDetailFieldNumber = 3,
    kErrorFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // string status_detail = 3 [json_name = "statusDetail"];
  void clear_status_detail();
  const std::string& status_detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status_detail();
  PROTOBUF_NODISCARD std::string* release_status_detail();
  void set_allocated_status_detail(std::string* status_detail);
  private:
  const std::string& _internal_status_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status_detail(const std::string& value);
  std::string* _internal_mutable_status_detail();
  public:

  // .dingodb.pb.error.Error error = 1 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::dingodb::pb::error::Error& error() const;
  PROTOBUF_NODISCARD ::dingodb::pb::error::Error* release_error();
  ::dingodb::pb::error::Error* mutable_error();
  void set_allocated_error(::dingodb::pb::error::Error* error);
  private:
  const ::dingodb::pb::error::Error& _internal_error() const;
  ::dingodb::pb::error::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::dingodb::pb::error::Error* error);
  ::dingodb::pb::error::Error* unsafe_arena_release_error();

  // .dingodb.pb.common.CoordinatorState state = 2 [json_name = "state"];
  void clear_state();
  ::dingodb::pb::common::CoordinatorState state() const;
  void set_state(::dingodb::pb::common::CoordinatorState value);
  private:
  ::dingodb::pb::common::CoordinatorState _internal_state() const;
  void _internal_set_state(::dingodb::pb::common::CoordinatorState value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.coordinator.HelloResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_detail_;
    ::dingodb::pb::error::Error* error_;
    int state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coordinator_2eproto;
};
// -------------------------------------------------------------------

class GetRegionMapRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.coordinator.GetRegionMapRequest) */ {
 public:
  inline GetRegionMapRequest() : GetRegionMapRequest(nullptr) {}
  ~GetRegionMapRequest() override;
  explicit PROTOBUF_CONSTEXPR GetRegionMapRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRegionMapRequest(const GetRegionMapRequest& from);
  GetRegionMapRequest(GetRegionMapRequest&& from) noexcept
    : GetRegionMapRequest() {
    *this = ::std::move(from);
  }

  inline GetRegionMapRequest& operator=(const GetRegionMapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRegionMapRequest& operator=(GetRegionMapRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRegionMapRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRegionMapRequest* internal_default_instance() {
    return reinterpret_cast<const GetRegionMapRequest*>(
               &_GetRegionMapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetRegionMapRequest& a, GetRegionMapRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRegionMapRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRegionMapRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRegionMapRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRegionMapRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRegionMapRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRegionMapRequest& from) {
    GetRegionMapRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRegionMapRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.coordinator.GetRegionMapRequest";
  }
  protected:
  explicit GetRegionMapRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpochFieldNumber = 1,
  };
  // uint64 epoch = 1 [json_name = "epoch"];
  void clear_epoch();
  uint64_t epoch() const;
  void set_epoch(uint64_t value);
  private:
  uint64_t _internal_epoch() const;
  void _internal_set_epoch(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.coordinator.GetRegionMapRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t epoch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coordinator_2eproto;
};
// -------------------------------------------------------------------

class GetRegionMapResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.coordinator.GetRegionMapResponse) */ {
 public:
  inline GetRegionMapResponse() : GetRegionMapResponse(nullptr) {}
  ~GetRegionMapResponse() override;
  explicit PROTOBUF_CONSTEXPR GetRegionMapResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRegionMapResponse(const GetRegionMapResponse& from);
  GetRegionMapResponse(GetRegionMapResponse&& from) noexcept
    : GetRegionMapResponse() {
    *this = ::std::move(from);
  }

  inline GetRegionMapResponse& operator=(const GetRegionMapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRegionMapResponse& operator=(GetRegionMapResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRegionMapResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRegionMapResponse* internal_default_instance() {
    return reinterpret_cast<const GetRegionMapResponse*>(
               &_GetRegionMapResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetRegionMapResponse& a, GetRegionMapResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRegionMapResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRegionMapResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRegionMapResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRegionMapResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRegionMapResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRegionMapResponse& from) {
    GetRegionMapResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRegionMapResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.coordinator.GetRegionMapResponse";
  }
  protected:
  explicit GetRegionMapResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kRegionmapFieldNumber = 3,
    kEpochFieldNumber = 2,
  };
  // .dingodb.pb.error.Error error = 1 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::dingodb::pb::error::Error& error() const;
  PROTOBUF_NODISCARD ::dingodb::pb::error::Error* release_error();
  ::dingodb::pb::error::Error* mutable_error();
  void set_allocated_error(::dingodb::pb::error::Error* error);
  private:
  const ::dingodb::pb::error::Error& _internal_error() const;
  ::dingodb::pb::error::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::dingodb::pb::error::Error* error);
  ::dingodb::pb::error::Error* unsafe_arena_release_error();

  // .dingodb.pb.common.RegionMap regionmap = 3 [json_name = "regionmap"];
  bool has_regionmap() const;
  private:
  bool _internal_has_regionmap() const;
  public:
  void clear_regionmap();
  const ::dingodb::pb::common::RegionMap& regionmap() const;
  PROTOBUF_NODISCARD ::dingodb::pb::common::RegionMap* release_regionmap();
  ::dingodb::pb::common::RegionMap* mutable_regionmap();
  void set_allocated_regionmap(::dingodb::pb::common::RegionMap* regionmap);
  private:
  const ::dingodb::pb::common::RegionMap& _internal_regionmap() const;
  ::dingodb::pb::common::RegionMap* _internal_mutable_regionmap();
  public:
  void unsafe_arena_set_allocated_regionmap(
      ::dingodb::pb::common::RegionMap* regionmap);
  ::dingodb::pb::common::RegionMap* unsafe_arena_release_regionmap();

  // uint64 epoch = 2 [json_name = "epoch"];
  void clear_epoch();
  uint64_t epoch() const;
  void set_epoch(uint64_t value);
  private:
  uint64_t _internal_epoch() const;
  void _internal_set_epoch(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.coordinator.GetRegionMapResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dingodb::pb::error::Error* error_;
    ::dingodb::pb::common::RegionMap* regionmap_;
    uint64_t epoch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coordinator_2eproto;
};
// -------------------------------------------------------------------

class GetStoreMapRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.coordinator.GetStoreMapRequest) */ {
 public:
  inline GetStoreMapRequest() : GetStoreMapRequest(nullptr) {}
  ~GetStoreMapRequest() override;
  explicit PROTOBUF_CONSTEXPR GetStoreMapRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStoreMapRequest(const GetStoreMapRequest& from);
  GetStoreMapRequest(GetStoreMapRequest&& from) noexcept
    : GetStoreMapRequest() {
    *this = ::std::move(from);
  }

  inline GetStoreMapRequest& operator=(const GetStoreMapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStoreMapRequest& operator=(GetStoreMapRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStoreMapRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStoreMapRequest* internal_default_instance() {
    return reinterpret_cast<const GetStoreMapRequest*>(
               &_GetStoreMapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetStoreMapRequest& a, GetStoreMapRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStoreMapRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStoreMapRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStoreMapRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStoreMapRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStoreMapRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStoreMapRequest& from) {
    GetStoreMapRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStoreMapRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.coordinator.GetStoreMapRequest";
  }
  protected:
  explicit GetStoreMapRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpochFieldNumber = 1,
  };
  // uint64 epoch = 1 [json_name = "epoch"];
  void clear_epoch();
  uint64_t epoch() const;
  void set_epoch(uint64_t value);
  private:
  uint64_t _internal_epoch() const;
  void _internal_set_epoch(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.coordinator.GetStoreMapRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t epoch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coordinator_2eproto;
};
// -------------------------------------------------------------------

class GetStoreMapResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.coordinator.GetStoreMapResponse) */ {
 public:
  inline GetStoreMapResponse() : GetStoreMapResponse(nullptr) {}
  ~GetStoreMapResponse() override;
  explicit PROTOBUF_CONSTEXPR GetStoreMapResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStoreMapResponse(const GetStoreMapResponse& from);
  GetStoreMapResponse(GetStoreMapResponse&& from) noexcept
    : GetStoreMapResponse() {
    *this = ::std::move(from);
  }

  inline GetStoreMapResponse& operator=(const GetStoreMapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStoreMapResponse& operator=(GetStoreMapResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStoreMapResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStoreMapResponse* internal_default_instance() {
    return reinterpret_cast<const GetStoreMapResponse*>(
               &_GetStoreMapResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetStoreMapResponse& a, GetStoreMapResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStoreMapResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStoreMapResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStoreMapResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStoreMapResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStoreMapResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStoreMapResponse& from) {
    GetStoreMapResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStoreMapResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.coordinator.GetStoreMapResponse";
  }
  protected:
  explicit GetStoreMapResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kStoremapFieldNumber = 3,
    kEpochFieldNumber = 2,
  };
  // .dingodb.pb.error.Error error = 1 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::dingodb::pb::error::Error& error() const;
  PROTOBUF_NODISCARD ::dingodb::pb::error::Error* release_error();
  ::dingodb::pb::error::Error* mutable_error();
  void set_allocated_error(::dingodb::pb::error::Error* error);
  private:
  const ::dingodb::pb::error::Error& _internal_error() const;
  ::dingodb::pb::error::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::dingodb::pb::error::Error* error);
  ::dingodb::pb::error::Error* unsafe_arena_release_error();

  // .dingodb.pb.common.StoreMap storemap = 3 [json_name = "storemap"];
  bool has_storemap() const;
  private:
  bool _internal_has_storemap() const;
  public:
  void clear_storemap();
  const ::dingodb::pb::common::StoreMap& storemap() const;
  PROTOBUF_NODISCARD ::dingodb::pb::common::StoreMap* release_storemap();
  ::dingodb::pb::common::StoreMap* mutable_storemap();
  void set_allocated_storemap(::dingodb::pb::common::StoreMap* storemap);
  private:
  const ::dingodb::pb::common::StoreMap& _internal_storemap() const;
  ::dingodb::pb::common::StoreMap* _internal_mutable_storemap();
  public:
  void unsafe_arena_set_allocated_storemap(
      ::dingodb::pb::common::StoreMap* storemap);
  ::dingodb::pb::common::StoreMap* unsafe_arena_release_storemap();

  // uint64 epoch = 2 [json_name = "epoch"];
  void clear_epoch();
  uint64_t epoch() const;
  void set_epoch(uint64_t value);
  private:
  uint64_t _internal_epoch() const;
  void _internal_set_epoch(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.coordinator.GetStoreMapResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::dingodb::pb::error::Error* error_;
    ::dingodb::pb::common::StoreMap* storemap_;
    uint64_t epoch_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coordinator_2eproto;
};
// -------------------------------------------------------------------

class CreateStoreRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.coordinator.CreateStoreRequest) */ {
 public:
  inline CreateStoreRequest() : CreateStoreRequest(nullptr) {}
  ~CreateStoreRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateStoreRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateStoreRequest(const CreateStoreRequest& from);
  CreateStoreRequest(CreateStoreRequest&& from) noexcept
    : CreateStoreRequest() {
    *this = ::std::move(from);
  }

  inline CreateStoreRequest& operator=(const CreateStoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateStoreRequest& operator=(CreateStoreRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateStoreRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateStoreRequest* internal_default_instance() {
    return reinterpret_cast<const CreateStoreRequest*>(
               &_CreateStoreRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CreateStoreRequest& a, CreateStoreRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateStoreRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateStoreRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateStoreRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateStoreRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateStoreRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateStoreRequest& from) {
    CreateStoreRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateStoreRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.coordinator.CreateStoreRequest";
  }
  protected:
  explicit CreateStoreRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClusterIdFieldNumber = 1,
  };
  // uint64 cluster_id = 1 [json_name = "clusterId"];
  void clear_cluster_id();
  uint64_t cluster_id() const;
  void set_cluster_id(uint64_t value);
  private:
  uint64_t _internal_cluster_id() const;
  void _internal_set_cluster_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.coordinator.CreateStoreRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t cluster_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coordinator_2eproto;
};
// -------------------------------------------------------------------

class CreateStoreResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dingodb.pb.coordinator.CreateStoreResponse) */ {
 public:
  inline CreateStoreResponse() : CreateStoreResponse(nullptr) {}
  ~CreateStoreResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateStoreResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateStoreResponse(const CreateStoreResponse& from);
  CreateStoreResponse(CreateStoreResponse&& from) noexcept
    : CreateStoreResponse() {
    *this = ::std::move(from);
  }

  inline CreateStoreResponse& operator=(const CreateStoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateStoreResponse& operator=(CreateStoreResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateStoreResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateStoreResponse* internal_default_instance() {
    return reinterpret_cast<const CreateStoreResponse*>(
               &_CreateStoreResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreateStoreResponse& a, CreateStoreResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateStoreResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateStoreResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateStoreResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateStoreResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateStoreResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateStoreResponse& from) {
    CreateStoreResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateStoreResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dingodb.pb.coordinator.CreateStoreResponse";
  }
  protected:
  explicit CreateStoreResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 3,
    kErrorFieldNumber = 1,
    kStoreIdFieldNumber = 2,
  };
  // string password = 3 [json_name = "password"];
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .dingodb.pb.error.Error error = 1 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::dingodb::pb::error::Error& error() const;
  PROTOBUF_NODISCARD ::dingodb::pb::error::Error* release_error();
  ::dingodb::pb::error::Error* mutable_error();
  void set_allocated_error(::dingodb::pb::error::Error* error);
  private:
  const ::dingodb::pb::error::Error& _internal_error() const;
  ::dingodb::pb::error::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::dingodb::pb::error::Error* error);
  ::dingodb::pb::error::Error* unsafe_arena_release_error();

  // uint64 store_id = 2 [json_name = "storeId"];
  void clear_store_id();
  uint64_t store_id() const;
  void set_store_id(uint64_t value);
  private:
  uint64_t _internal_store_id() const;
  void _internal_set_store_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:dingodb.pb.coordinator.CreateStoreResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::dingodb::pb::error::Error* error_;
    uint64_t store_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_coordinator_2eproto;
};
// ===================================================================

class CoordinatorService_Stub;

class CoordinatorService : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline CoordinatorService() {};
 public:
  virtual ~CoordinatorService();

  typedef CoordinatorService_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void Hello(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::coordinator::HelloRequest* request,
                       ::dingodb::pb::coordinator::HelloResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void StoreHeartbeat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::coordinator::StoreHeartbeatRequest* request,
                       ::dingodb::pb::coordinator::StoreHeartbeatResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void GetRegionMap(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::coordinator::GetRegionMapRequest* request,
                       ::dingodb::pb::coordinator::GetRegionMapResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void GetStoreMap(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::coordinator::GetStoreMapRequest* request,
                       ::dingodb::pb::coordinator::GetStoreMapResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void CreateStore(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::coordinator::CreateStoreRequest* request,
                       ::dingodb::pb::coordinator::CreateStoreResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(CoordinatorService);
};

class CoordinatorService_Stub : public CoordinatorService {
 public:
  CoordinatorService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  CoordinatorService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~CoordinatorService_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements CoordinatorService ------------------------------------------

  void Hello(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::coordinator::HelloRequest* request,
                       ::dingodb::pb::coordinator::HelloResponse* response,
                       ::google::protobuf::Closure* done);
  void StoreHeartbeat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::coordinator::StoreHeartbeatRequest* request,
                       ::dingodb::pb::coordinator::StoreHeartbeatResponse* response,
                       ::google::protobuf::Closure* done);
  void GetRegionMap(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::coordinator::GetRegionMapRequest* request,
                       ::dingodb::pb::coordinator::GetRegionMapResponse* response,
                       ::google::protobuf::Closure* done);
  void GetStoreMap(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::coordinator::GetStoreMapRequest* request,
                       ::dingodb::pb::coordinator::GetStoreMapResponse* response,
                       ::google::protobuf::Closure* done);
  void CreateStore(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dingodb::pb::coordinator::CreateStoreRequest* request,
                       ::dingodb::pb::coordinator::CreateStoreResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(CoordinatorService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StoreHeartbeatRequest

// uint64 self_storemap_epoch = 1 [json_name = "selfStoremapEpoch"];
inline void StoreHeartbeatRequest::clear_self_storemap_epoch() {
  _impl_.self_storemap_epoch_ = uint64_t{0u};
}
inline uint64_t StoreHeartbeatRequest::_internal_self_storemap_epoch() const {
  return _impl_.self_storemap_epoch_;
}
inline uint64_t StoreHeartbeatRequest::self_storemap_epoch() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.StoreHeartbeatRequest.self_storemap_epoch)
  return _internal_self_storemap_epoch();
}
inline void StoreHeartbeatRequest::_internal_set_self_storemap_epoch(uint64_t value) {
  
  _impl_.self_storemap_epoch_ = value;
}
inline void StoreHeartbeatRequest::set_self_storemap_epoch(uint64_t value) {
  _internal_set_self_storemap_epoch(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.coordinator.StoreHeartbeatRequest.self_storemap_epoch)
}

// uint64 self_regionmap_epoch = 2 [json_name = "selfRegionmapEpoch"];
inline void StoreHeartbeatRequest::clear_self_regionmap_epoch() {
  _impl_.self_regionmap_epoch_ = uint64_t{0u};
}
inline uint64_t StoreHeartbeatRequest::_internal_self_regionmap_epoch() const {
  return _impl_.self_regionmap_epoch_;
}
inline uint64_t StoreHeartbeatRequest::self_regionmap_epoch() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.StoreHeartbeatRequest.self_regionmap_epoch)
  return _internal_self_regionmap_epoch();
}
inline void StoreHeartbeatRequest::_internal_set_self_regionmap_epoch(uint64_t value) {
  
  _impl_.self_regionmap_epoch_ = value;
}
inline void StoreHeartbeatRequest::set_self_regionmap_epoch(uint64_t value) {
  _internal_set_self_regionmap_epoch(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.coordinator.StoreHeartbeatRequest.self_regionmap_epoch)
}

// .dingodb.pb.common.Store store = 3 [json_name = "store"];
inline bool StoreHeartbeatRequest::_internal_has_store() const {
  return this != internal_default_instance() && _impl_.store_ != nullptr;
}
inline bool StoreHeartbeatRequest::has_store() const {
  return _internal_has_store();
}
inline const ::dingodb::pb::common::Store& StoreHeartbeatRequest::_internal_store() const {
  const ::dingodb::pb::common::Store* p = _impl_.store_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::common::Store&>(
      ::dingodb::pb::common::_Store_default_instance_);
}
inline const ::dingodb::pb::common::Store& StoreHeartbeatRequest::store() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.StoreHeartbeatRequest.store)
  return _internal_store();
}
inline void StoreHeartbeatRequest::unsafe_arena_set_allocated_store(
    ::dingodb::pb::common::Store* store) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.store_);
  }
  _impl_.store_ = store;
  if (store) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.coordinator.StoreHeartbeatRequest.store)
}
inline ::dingodb::pb::common::Store* StoreHeartbeatRequest::release_store() {
  
  ::dingodb::pb::common::Store* temp = _impl_.store_;
  _impl_.store_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::common::Store* StoreHeartbeatRequest::unsafe_arena_release_store() {
  // @@protoc_insertion_point(field_release:dingodb.pb.coordinator.StoreHeartbeatRequest.store)
  
  ::dingodb::pb::common::Store* temp = _impl_.store_;
  _impl_.store_ = nullptr;
  return temp;
}
inline ::dingodb::pb::common::Store* StoreHeartbeatRequest::_internal_mutable_store() {
  
  if (_impl_.store_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::common::Store>(GetArenaForAllocation());
    _impl_.store_ = p;
  }
  return _impl_.store_;
}
inline ::dingodb::pb::common::Store* StoreHeartbeatRequest::mutable_store() {
  ::dingodb::pb::common::Store* _msg = _internal_mutable_store();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.coordinator.StoreHeartbeatRequest.store)
  return _msg;
}
inline void StoreHeartbeatRequest::set_allocated_store(::dingodb::pb::common::Store* store) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.store_);
  }
  if (store) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(store));
    if (message_arena != submessage_arena) {
      store = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, store, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.store_ = store;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.coordinator.StoreHeartbeatRequest.store)
}

// repeated .dingodb.pb.common.Region regions = 4 [json_name = "regions"];
inline int StoreHeartbeatRequest::_internal_regions_size() const {
  return _impl_.regions_.size();
}
inline int StoreHeartbeatRequest::regions_size() const {
  return _internal_regions_size();
}
inline ::dingodb::pb::common::Region* StoreHeartbeatRequest::mutable_regions(int index) {
  // @@protoc_insertion_point(field_mutable:dingodb.pb.coordinator.StoreHeartbeatRequest.regions)
  return _impl_.regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Region >*
StoreHeartbeatRequest::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:dingodb.pb.coordinator.StoreHeartbeatRequest.regions)
  return &_impl_.regions_;
}
inline const ::dingodb::pb::common::Region& StoreHeartbeatRequest::_internal_regions(int index) const {
  return _impl_.regions_.Get(index);
}
inline const ::dingodb::pb::common::Region& StoreHeartbeatRequest::regions(int index) const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.StoreHeartbeatRequest.regions)
  return _internal_regions(index);
}
inline ::dingodb::pb::common::Region* StoreHeartbeatRequest::_internal_add_regions() {
  return _impl_.regions_.Add();
}
inline ::dingodb::pb::common::Region* StoreHeartbeatRequest::add_regions() {
  ::dingodb::pb::common::Region* _add = _internal_add_regions();
  // @@protoc_insertion_point(field_add:dingodb.pb.coordinator.StoreHeartbeatRequest.regions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dingodb::pb::common::Region >&
StoreHeartbeatRequest::regions() const {
  // @@protoc_insertion_point(field_list:dingodb.pb.coordinator.StoreHeartbeatRequest.regions)
  return _impl_.regions_;
}

// -------------------------------------------------------------------

// StoreHeartbeatResponse

// .dingodb.pb.error.Error error = 1 [json_name = "error"];
inline bool StoreHeartbeatResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool StoreHeartbeatResponse::has_error() const {
  return _internal_has_error();
}
inline const ::dingodb::pb::error::Error& StoreHeartbeatResponse::_internal_error() const {
  const ::dingodb::pb::error::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::error::Error&>(
      ::dingodb::pb::error::_Error_default_instance_);
}
inline const ::dingodb::pb::error::Error& StoreHeartbeatResponse::error() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.StoreHeartbeatResponse.error)
  return _internal_error();
}
inline void StoreHeartbeatResponse::unsafe_arena_set_allocated_error(
    ::dingodb::pb::error::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.coordinator.StoreHeartbeatResponse.error)
}
inline ::dingodb::pb::error::Error* StoreHeartbeatResponse::release_error() {
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::error::Error* StoreHeartbeatResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:dingodb.pb.coordinator.StoreHeartbeatResponse.error)
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::dingodb::pb::error::Error* StoreHeartbeatResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::error::Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::dingodb::pb::error::Error* StoreHeartbeatResponse::mutable_error() {
  ::dingodb::pb::error::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.coordinator.StoreHeartbeatResponse.error)
  return _msg;
}
inline void StoreHeartbeatResponse::set_allocated_error(::dingodb::pb::error::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.coordinator.StoreHeartbeatResponse.error)
}

// uint64 storemap_epoch = 2 [json_name = "storemapEpoch"];
inline void StoreHeartbeatResponse::clear_storemap_epoch() {
  _impl_.storemap_epoch_ = uint64_t{0u};
}
inline uint64_t StoreHeartbeatResponse::_internal_storemap_epoch() const {
  return _impl_.storemap_epoch_;
}
inline uint64_t StoreHeartbeatResponse::storemap_epoch() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.StoreHeartbeatResponse.storemap_epoch)
  return _internal_storemap_epoch();
}
inline void StoreHeartbeatResponse::_internal_set_storemap_epoch(uint64_t value) {
  
  _impl_.storemap_epoch_ = value;
}
inline void StoreHeartbeatResponse::set_storemap_epoch(uint64_t value) {
  _internal_set_storemap_epoch(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.coordinator.StoreHeartbeatResponse.storemap_epoch)
}

// uint64 regionmap_epoch = 3 [json_name = "regionmapEpoch"];
inline void StoreHeartbeatResponse::clear_regionmap_epoch() {
  _impl_.regionmap_epoch_ = uint64_t{0u};
}
inline uint64_t StoreHeartbeatResponse::_internal_regionmap_epoch() const {
  return _impl_.regionmap_epoch_;
}
inline uint64_t StoreHeartbeatResponse::regionmap_epoch() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.StoreHeartbeatResponse.regionmap_epoch)
  return _internal_regionmap_epoch();
}
inline void StoreHeartbeatResponse::_internal_set_regionmap_epoch(uint64_t value) {
  
  _impl_.regionmap_epoch_ = value;
}
inline void StoreHeartbeatResponse::set_regionmap_epoch(uint64_t value) {
  _internal_set_regionmap_epoch(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.coordinator.StoreHeartbeatResponse.regionmap_epoch)
}

// .dingodb.pb.common.StoreMap storemap = 4 [json_name = "storemap"];
inline bool StoreHeartbeatResponse::_internal_has_storemap() const {
  return this != internal_default_instance() && _impl_.storemap_ != nullptr;
}
inline bool StoreHeartbeatResponse::has_storemap() const {
  return _internal_has_storemap();
}
inline const ::dingodb::pb::common::StoreMap& StoreHeartbeatResponse::_internal_storemap() const {
  const ::dingodb::pb::common::StoreMap* p = _impl_.storemap_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::common::StoreMap&>(
      ::dingodb::pb::common::_StoreMap_default_instance_);
}
inline const ::dingodb::pb::common::StoreMap& StoreHeartbeatResponse::storemap() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.StoreHeartbeatResponse.storemap)
  return _internal_storemap();
}
inline void StoreHeartbeatResponse::unsafe_arena_set_allocated_storemap(
    ::dingodb::pb::common::StoreMap* storemap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storemap_);
  }
  _impl_.storemap_ = storemap;
  if (storemap) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.coordinator.StoreHeartbeatResponse.storemap)
}
inline ::dingodb::pb::common::StoreMap* StoreHeartbeatResponse::release_storemap() {
  
  ::dingodb::pb::common::StoreMap* temp = _impl_.storemap_;
  _impl_.storemap_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::common::StoreMap* StoreHeartbeatResponse::unsafe_arena_release_storemap() {
  // @@protoc_insertion_point(field_release:dingodb.pb.coordinator.StoreHeartbeatResponse.storemap)
  
  ::dingodb::pb::common::StoreMap* temp = _impl_.storemap_;
  _impl_.storemap_ = nullptr;
  return temp;
}
inline ::dingodb::pb::common::StoreMap* StoreHeartbeatResponse::_internal_mutable_storemap() {
  
  if (_impl_.storemap_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::common::StoreMap>(GetArenaForAllocation());
    _impl_.storemap_ = p;
  }
  return _impl_.storemap_;
}
inline ::dingodb::pb::common::StoreMap* StoreHeartbeatResponse::mutable_storemap() {
  ::dingodb::pb::common::StoreMap* _msg = _internal_mutable_storemap();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.coordinator.StoreHeartbeatResponse.storemap)
  return _msg;
}
inline void StoreHeartbeatResponse::set_allocated_storemap(::dingodb::pb::common::StoreMap* storemap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storemap_);
  }
  if (storemap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storemap));
    if (message_arena != submessage_arena) {
      storemap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storemap, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.storemap_ = storemap;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.coordinator.StoreHeartbeatResponse.storemap)
}

// .dingodb.pb.common.RegionMap regionmap = 5 [json_name = "regionmap"];
inline bool StoreHeartbeatResponse::_internal_has_regionmap() const {
  return this != internal_default_instance() && _impl_.regionmap_ != nullptr;
}
inline bool StoreHeartbeatResponse::has_regionmap() const {
  return _internal_has_regionmap();
}
inline const ::dingodb::pb::common::RegionMap& StoreHeartbeatResponse::_internal_regionmap() const {
  const ::dingodb::pb::common::RegionMap* p = _impl_.regionmap_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::common::RegionMap&>(
      ::dingodb::pb::common::_RegionMap_default_instance_);
}
inline const ::dingodb::pb::common::RegionMap& StoreHeartbeatResponse::regionmap() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.StoreHeartbeatResponse.regionmap)
  return _internal_regionmap();
}
inline void StoreHeartbeatResponse::unsafe_arena_set_allocated_regionmap(
    ::dingodb::pb::common::RegionMap* regionmap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regionmap_);
  }
  _impl_.regionmap_ = regionmap;
  if (regionmap) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.coordinator.StoreHeartbeatResponse.regionmap)
}
inline ::dingodb::pb::common::RegionMap* StoreHeartbeatResponse::release_regionmap() {
  
  ::dingodb::pb::common::RegionMap* temp = _impl_.regionmap_;
  _impl_.regionmap_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::common::RegionMap* StoreHeartbeatResponse::unsafe_arena_release_regionmap() {
  // @@protoc_insertion_point(field_release:dingodb.pb.coordinator.StoreHeartbeatResponse.regionmap)
  
  ::dingodb::pb::common::RegionMap* temp = _impl_.regionmap_;
  _impl_.regionmap_ = nullptr;
  return temp;
}
inline ::dingodb::pb::common::RegionMap* StoreHeartbeatResponse::_internal_mutable_regionmap() {
  
  if (_impl_.regionmap_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::common::RegionMap>(GetArenaForAllocation());
    _impl_.regionmap_ = p;
  }
  return _impl_.regionmap_;
}
inline ::dingodb::pb::common::RegionMap* StoreHeartbeatResponse::mutable_regionmap() {
  ::dingodb::pb::common::RegionMap* _msg = _internal_mutable_regionmap();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.coordinator.StoreHeartbeatResponse.regionmap)
  return _msg;
}
inline void StoreHeartbeatResponse::set_allocated_regionmap(::dingodb::pb::common::RegionMap* regionmap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regionmap_);
  }
  if (regionmap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(regionmap));
    if (message_arena != submessage_arena) {
      regionmap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regionmap, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.regionmap_ = regionmap;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.coordinator.StoreHeartbeatResponse.regionmap)
}

// -------------------------------------------------------------------

// HelloRequest

// uint64 hello = 1 [json_name = "hello"];
inline void HelloRequest::clear_hello() {
  _impl_.hello_ = uint64_t{0u};
}
inline uint64_t HelloRequest::_internal_hello() const {
  return _impl_.hello_;
}
inline uint64_t HelloRequest::hello() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.HelloRequest.hello)
  return _internal_hello();
}
inline void HelloRequest::_internal_set_hello(uint64_t value) {
  
  _impl_.hello_ = value;
}
inline void HelloRequest::set_hello(uint64_t value) {
  _internal_set_hello(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.coordinator.HelloRequest.hello)
}

// -------------------------------------------------------------------

// HelloResponse

// .dingodb.pb.error.Error error = 1 [json_name = "error"];
inline bool HelloResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool HelloResponse::has_error() const {
  return _internal_has_error();
}
inline const ::dingodb::pb::error::Error& HelloResponse::_internal_error() const {
  const ::dingodb::pb::error::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::error::Error&>(
      ::dingodb::pb::error::_Error_default_instance_);
}
inline const ::dingodb::pb::error::Error& HelloResponse::error() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.HelloResponse.error)
  return _internal_error();
}
inline void HelloResponse::unsafe_arena_set_allocated_error(
    ::dingodb::pb::error::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.coordinator.HelloResponse.error)
}
inline ::dingodb::pb::error::Error* HelloResponse::release_error() {
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::error::Error* HelloResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:dingodb.pb.coordinator.HelloResponse.error)
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::dingodb::pb::error::Error* HelloResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::error::Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::dingodb::pb::error::Error* HelloResponse::mutable_error() {
  ::dingodb::pb::error::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.coordinator.HelloResponse.error)
  return _msg;
}
inline void HelloResponse::set_allocated_error(::dingodb::pb::error::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.coordinator.HelloResponse.error)
}

// .dingodb.pb.common.CoordinatorState state = 2 [json_name = "state"];
inline void HelloResponse::clear_state() {
  _impl_.state_ = 0;
}
inline ::dingodb::pb::common::CoordinatorState HelloResponse::_internal_state() const {
  return static_cast< ::dingodb::pb::common::CoordinatorState >(_impl_.state_);
}
inline ::dingodb::pb::common::CoordinatorState HelloResponse::state() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.HelloResponse.state)
  return _internal_state();
}
inline void HelloResponse::_internal_set_state(::dingodb::pb::common::CoordinatorState value) {
  
  _impl_.state_ = value;
}
inline void HelloResponse::set_state(::dingodb::pb::common::CoordinatorState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.coordinator.HelloResponse.state)
}

// string status_detail = 3 [json_name = "statusDetail"];
inline void HelloResponse::clear_status_detail() {
  _impl_.status_detail_.ClearToEmpty();
}
inline const std::string& HelloResponse::status_detail() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.HelloResponse.status_detail)
  return _internal_status_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloResponse::set_status_detail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_detail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dingodb.pb.coordinator.HelloResponse.status_detail)
}
inline std::string* HelloResponse::mutable_status_detail() {
  std::string* _s = _internal_mutable_status_detail();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.coordinator.HelloResponse.status_detail)
  return _s;
}
inline const std::string& HelloResponse::_internal_status_detail() const {
  return _impl_.status_detail_.Get();
}
inline void HelloResponse::_internal_set_status_detail(const std::string& value) {
  
  _impl_.status_detail_.Set(value, GetArenaForAllocation());
}
inline std::string* HelloResponse::_internal_mutable_status_detail() {
  
  return _impl_.status_detail_.Mutable(GetArenaForAllocation());
}
inline std::string* HelloResponse::release_status_detail() {
  // @@protoc_insertion_point(field_release:dingodb.pb.coordinator.HelloResponse.status_detail)
  return _impl_.status_detail_.Release();
}
inline void HelloResponse::set_allocated_status_detail(std::string* status_detail) {
  if (status_detail != nullptr) {
    
  } else {
    
  }
  _impl_.status_detail_.SetAllocated(status_detail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_detail_.IsDefault()) {
    _impl_.status_detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.coordinator.HelloResponse.status_detail)
}

// -------------------------------------------------------------------

// GetRegionMapRequest

// uint64 epoch = 1 [json_name = "epoch"];
inline void GetRegionMapRequest::clear_epoch() {
  _impl_.epoch_ = uint64_t{0u};
}
inline uint64_t GetRegionMapRequest::_internal_epoch() const {
  return _impl_.epoch_;
}
inline uint64_t GetRegionMapRequest::epoch() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.GetRegionMapRequest.epoch)
  return _internal_epoch();
}
inline void GetRegionMapRequest::_internal_set_epoch(uint64_t value) {
  
  _impl_.epoch_ = value;
}
inline void GetRegionMapRequest::set_epoch(uint64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.coordinator.GetRegionMapRequest.epoch)
}

// -------------------------------------------------------------------

// GetRegionMapResponse

// .dingodb.pb.error.Error error = 1 [json_name = "error"];
inline bool GetRegionMapResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool GetRegionMapResponse::has_error() const {
  return _internal_has_error();
}
inline const ::dingodb::pb::error::Error& GetRegionMapResponse::_internal_error() const {
  const ::dingodb::pb::error::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::error::Error&>(
      ::dingodb::pb::error::_Error_default_instance_);
}
inline const ::dingodb::pb::error::Error& GetRegionMapResponse::error() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.GetRegionMapResponse.error)
  return _internal_error();
}
inline void GetRegionMapResponse::unsafe_arena_set_allocated_error(
    ::dingodb::pb::error::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.coordinator.GetRegionMapResponse.error)
}
inline ::dingodb::pb::error::Error* GetRegionMapResponse::release_error() {
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::error::Error* GetRegionMapResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:dingodb.pb.coordinator.GetRegionMapResponse.error)
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::dingodb::pb::error::Error* GetRegionMapResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::error::Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::dingodb::pb::error::Error* GetRegionMapResponse::mutable_error() {
  ::dingodb::pb::error::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.coordinator.GetRegionMapResponse.error)
  return _msg;
}
inline void GetRegionMapResponse::set_allocated_error(::dingodb::pb::error::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.coordinator.GetRegionMapResponse.error)
}

// uint64 epoch = 2 [json_name = "epoch"];
inline void GetRegionMapResponse::clear_epoch() {
  _impl_.epoch_ = uint64_t{0u};
}
inline uint64_t GetRegionMapResponse::_internal_epoch() const {
  return _impl_.epoch_;
}
inline uint64_t GetRegionMapResponse::epoch() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.GetRegionMapResponse.epoch)
  return _internal_epoch();
}
inline void GetRegionMapResponse::_internal_set_epoch(uint64_t value) {
  
  _impl_.epoch_ = value;
}
inline void GetRegionMapResponse::set_epoch(uint64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.coordinator.GetRegionMapResponse.epoch)
}

// .dingodb.pb.common.RegionMap regionmap = 3 [json_name = "regionmap"];
inline bool GetRegionMapResponse::_internal_has_regionmap() const {
  return this != internal_default_instance() && _impl_.regionmap_ != nullptr;
}
inline bool GetRegionMapResponse::has_regionmap() const {
  return _internal_has_regionmap();
}
inline const ::dingodb::pb::common::RegionMap& GetRegionMapResponse::_internal_regionmap() const {
  const ::dingodb::pb::common::RegionMap* p = _impl_.regionmap_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::common::RegionMap&>(
      ::dingodb::pb::common::_RegionMap_default_instance_);
}
inline const ::dingodb::pb::common::RegionMap& GetRegionMapResponse::regionmap() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.GetRegionMapResponse.regionmap)
  return _internal_regionmap();
}
inline void GetRegionMapResponse::unsafe_arena_set_allocated_regionmap(
    ::dingodb::pb::common::RegionMap* regionmap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regionmap_);
  }
  _impl_.regionmap_ = regionmap;
  if (regionmap) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.coordinator.GetRegionMapResponse.regionmap)
}
inline ::dingodb::pb::common::RegionMap* GetRegionMapResponse::release_regionmap() {
  
  ::dingodb::pb::common::RegionMap* temp = _impl_.regionmap_;
  _impl_.regionmap_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::common::RegionMap* GetRegionMapResponse::unsafe_arena_release_regionmap() {
  // @@protoc_insertion_point(field_release:dingodb.pb.coordinator.GetRegionMapResponse.regionmap)
  
  ::dingodb::pb::common::RegionMap* temp = _impl_.regionmap_;
  _impl_.regionmap_ = nullptr;
  return temp;
}
inline ::dingodb::pb::common::RegionMap* GetRegionMapResponse::_internal_mutable_regionmap() {
  
  if (_impl_.regionmap_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::common::RegionMap>(GetArenaForAllocation());
    _impl_.regionmap_ = p;
  }
  return _impl_.regionmap_;
}
inline ::dingodb::pb::common::RegionMap* GetRegionMapResponse::mutable_regionmap() {
  ::dingodb::pb::common::RegionMap* _msg = _internal_mutable_regionmap();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.coordinator.GetRegionMapResponse.regionmap)
  return _msg;
}
inline void GetRegionMapResponse::set_allocated_regionmap(::dingodb::pb::common::RegionMap* regionmap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.regionmap_);
  }
  if (regionmap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(regionmap));
    if (message_arena != submessage_arena) {
      regionmap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regionmap, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.regionmap_ = regionmap;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.coordinator.GetRegionMapResponse.regionmap)
}

// -------------------------------------------------------------------

// GetStoreMapRequest

// uint64 epoch = 1 [json_name = "epoch"];
inline void GetStoreMapRequest::clear_epoch() {
  _impl_.epoch_ = uint64_t{0u};
}
inline uint64_t GetStoreMapRequest::_internal_epoch() const {
  return _impl_.epoch_;
}
inline uint64_t GetStoreMapRequest::epoch() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.GetStoreMapRequest.epoch)
  return _internal_epoch();
}
inline void GetStoreMapRequest::_internal_set_epoch(uint64_t value) {
  
  _impl_.epoch_ = value;
}
inline void GetStoreMapRequest::set_epoch(uint64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.coordinator.GetStoreMapRequest.epoch)
}

// -------------------------------------------------------------------

// GetStoreMapResponse

// .dingodb.pb.error.Error error = 1 [json_name = "error"];
inline bool GetStoreMapResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool GetStoreMapResponse::has_error() const {
  return _internal_has_error();
}
inline const ::dingodb::pb::error::Error& GetStoreMapResponse::_internal_error() const {
  const ::dingodb::pb::error::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::error::Error&>(
      ::dingodb::pb::error::_Error_default_instance_);
}
inline const ::dingodb::pb::error::Error& GetStoreMapResponse::error() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.GetStoreMapResponse.error)
  return _internal_error();
}
inline void GetStoreMapResponse::unsafe_arena_set_allocated_error(
    ::dingodb::pb::error::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.coordinator.GetStoreMapResponse.error)
}
inline ::dingodb::pb::error::Error* GetStoreMapResponse::release_error() {
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::error::Error* GetStoreMapResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:dingodb.pb.coordinator.GetStoreMapResponse.error)
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::dingodb::pb::error::Error* GetStoreMapResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::error::Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::dingodb::pb::error::Error* GetStoreMapResponse::mutable_error() {
  ::dingodb::pb::error::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.coordinator.GetStoreMapResponse.error)
  return _msg;
}
inline void GetStoreMapResponse::set_allocated_error(::dingodb::pb::error::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.coordinator.GetStoreMapResponse.error)
}

// uint64 epoch = 2 [json_name = "epoch"];
inline void GetStoreMapResponse::clear_epoch() {
  _impl_.epoch_ = uint64_t{0u};
}
inline uint64_t GetStoreMapResponse::_internal_epoch() const {
  return _impl_.epoch_;
}
inline uint64_t GetStoreMapResponse::epoch() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.GetStoreMapResponse.epoch)
  return _internal_epoch();
}
inline void GetStoreMapResponse::_internal_set_epoch(uint64_t value) {
  
  _impl_.epoch_ = value;
}
inline void GetStoreMapResponse::set_epoch(uint64_t value) {
  _internal_set_epoch(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.coordinator.GetStoreMapResponse.epoch)
}

// .dingodb.pb.common.StoreMap storemap = 3 [json_name = "storemap"];
inline bool GetStoreMapResponse::_internal_has_storemap() const {
  return this != internal_default_instance() && _impl_.storemap_ != nullptr;
}
inline bool GetStoreMapResponse::has_storemap() const {
  return _internal_has_storemap();
}
inline const ::dingodb::pb::common::StoreMap& GetStoreMapResponse::_internal_storemap() const {
  const ::dingodb::pb::common::StoreMap* p = _impl_.storemap_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::common::StoreMap&>(
      ::dingodb::pb::common::_StoreMap_default_instance_);
}
inline const ::dingodb::pb::common::StoreMap& GetStoreMapResponse::storemap() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.GetStoreMapResponse.storemap)
  return _internal_storemap();
}
inline void GetStoreMapResponse::unsafe_arena_set_allocated_storemap(
    ::dingodb::pb::common::StoreMap* storemap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storemap_);
  }
  _impl_.storemap_ = storemap;
  if (storemap) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.coordinator.GetStoreMapResponse.storemap)
}
inline ::dingodb::pb::common::StoreMap* GetStoreMapResponse::release_storemap() {
  
  ::dingodb::pb::common::StoreMap* temp = _impl_.storemap_;
  _impl_.storemap_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::common::StoreMap* GetStoreMapResponse::unsafe_arena_release_storemap() {
  // @@protoc_insertion_point(field_release:dingodb.pb.coordinator.GetStoreMapResponse.storemap)
  
  ::dingodb::pb::common::StoreMap* temp = _impl_.storemap_;
  _impl_.storemap_ = nullptr;
  return temp;
}
inline ::dingodb::pb::common::StoreMap* GetStoreMapResponse::_internal_mutable_storemap() {
  
  if (_impl_.storemap_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::common::StoreMap>(GetArenaForAllocation());
    _impl_.storemap_ = p;
  }
  return _impl_.storemap_;
}
inline ::dingodb::pb::common::StoreMap* GetStoreMapResponse::mutable_storemap() {
  ::dingodb::pb::common::StoreMap* _msg = _internal_mutable_storemap();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.coordinator.GetStoreMapResponse.storemap)
  return _msg;
}
inline void GetStoreMapResponse::set_allocated_storemap(::dingodb::pb::common::StoreMap* storemap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storemap_);
  }
  if (storemap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storemap));
    if (message_arena != submessage_arena) {
      storemap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storemap, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.storemap_ = storemap;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.coordinator.GetStoreMapResponse.storemap)
}

// -------------------------------------------------------------------

// CreateStoreRequest

// uint64 cluster_id = 1 [json_name = "clusterId"];
inline void CreateStoreRequest::clear_cluster_id() {
  _impl_.cluster_id_ = uint64_t{0u};
}
inline uint64_t CreateStoreRequest::_internal_cluster_id() const {
  return _impl_.cluster_id_;
}
inline uint64_t CreateStoreRequest::cluster_id() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.CreateStoreRequest.cluster_id)
  return _internal_cluster_id();
}
inline void CreateStoreRequest::_internal_set_cluster_id(uint64_t value) {
  
  _impl_.cluster_id_ = value;
}
inline void CreateStoreRequest::set_cluster_id(uint64_t value) {
  _internal_set_cluster_id(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.coordinator.CreateStoreRequest.cluster_id)
}

// -------------------------------------------------------------------

// CreateStoreResponse

// .dingodb.pb.error.Error error = 1 [json_name = "error"];
inline bool CreateStoreResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool CreateStoreResponse::has_error() const {
  return _internal_has_error();
}
inline const ::dingodb::pb::error::Error& CreateStoreResponse::_internal_error() const {
  const ::dingodb::pb::error::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::dingodb::pb::error::Error&>(
      ::dingodb::pb::error::_Error_default_instance_);
}
inline const ::dingodb::pb::error::Error& CreateStoreResponse::error() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.CreateStoreResponse.error)
  return _internal_error();
}
inline void CreateStoreResponse::unsafe_arena_set_allocated_error(
    ::dingodb::pb::error::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dingodb.pb.coordinator.CreateStoreResponse.error)
}
inline ::dingodb::pb::error::Error* CreateStoreResponse::release_error() {
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dingodb::pb::error::Error* CreateStoreResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:dingodb.pb.coordinator.CreateStoreResponse.error)
  
  ::dingodb::pb::error::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::dingodb::pb::error::Error* CreateStoreResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::dingodb::pb::error::Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::dingodb::pb::error::Error* CreateStoreResponse::mutable_error() {
  ::dingodb::pb::error::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.coordinator.CreateStoreResponse.error)
  return _msg;
}
inline void CreateStoreResponse::set_allocated_error(::dingodb::pb::error::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.coordinator.CreateStoreResponse.error)
}

// uint64 store_id = 2 [json_name = "storeId"];
inline void CreateStoreResponse::clear_store_id() {
  _impl_.store_id_ = uint64_t{0u};
}
inline uint64_t CreateStoreResponse::_internal_store_id() const {
  return _impl_.store_id_;
}
inline uint64_t CreateStoreResponse::store_id() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.CreateStoreResponse.store_id)
  return _internal_store_id();
}
inline void CreateStoreResponse::_internal_set_store_id(uint64_t value) {
  
  _impl_.store_id_ = value;
}
inline void CreateStoreResponse::set_store_id(uint64_t value) {
  _internal_set_store_id(value);
  // @@protoc_insertion_point(field_set:dingodb.pb.coordinator.CreateStoreResponse.store_id)
}

// string password = 3 [json_name = "password"];
inline void CreateStoreResponse::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& CreateStoreResponse::password() const {
  // @@protoc_insertion_point(field_get:dingodb.pb.coordinator.CreateStoreResponse.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateStoreResponse::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dingodb.pb.coordinator.CreateStoreResponse.password)
}
inline std::string* CreateStoreResponse::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:dingodb.pb.coordinator.CreateStoreResponse.password)
  return _s;
}
inline const std::string& CreateStoreResponse::_internal_password() const {
  return _impl_.password_.Get();
}
inline void CreateStoreResponse::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateStoreResponse::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateStoreResponse::release_password() {
  // @@protoc_insertion_point(field_release:dingodb.pb.coordinator.CreateStoreResponse.password)
  return _impl_.password_.Release();
}
inline void CreateStoreResponse::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dingodb.pb.coordinator.CreateStoreResponse.password)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace coordinator
}  // namespace pb
}  // namespace dingodb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_coordinator_2eproto
